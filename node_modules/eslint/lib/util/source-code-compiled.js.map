{"version":3,"sources":["source-code.js"],"names":[],"mappings":"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","file":"source-code-compiled.js","sourcesContent":["/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n * @copyright 2015 Nicholas C. Zakas. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\";\n/* eslint no-underscore-dangle: 0*/\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar createTokenStore = require(\"../token-store.js\"),\n    estraverse = require(\"estraverse\"),\n    assign = require(\"object-assign\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Finds a JSDoc comment node in an array of comment nodes.\n * @param {ASTNode[]} comments The array of comment nodes to search.\n * @param {int} line Line number to look around\n * @returns {ASTNode} The node if found, null if not.\n * @private\n */\nfunction findJSDocComment(comments, line) {\n\n    if (comments) {\n        for (var i = comments.length - 1; i >= 0; i--) {\n            if (comments[i].type === \"Block\" && comments[i].value.charAt(0) === \"*\") {\n\n                if (line - comments[i].loc.end.line <= 1) {\n                    return comments[i];\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\n/**\n * Check to see if its a ES6 export declaration\n * @param {ASTNode} astNode - any node\n * @returns {boolean} whether the given node represents a export declaration\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Represents parsed source code.\n * @param {string} text The source code text.\n * @param {ASTNode} ast The Program node of the AST representing the code.\n * @constructor\n */\nfunction SourceCode(text, ast) {\n\n    validate(ast);\n\n    /**\n     * The original text source code.\n     * @type string\n     */\n    this.text = text;\n\n    /**\n     * The parsed AST for the source code.\n     * @type ASTNode\n     */\n    this.ast = ast;\n\n    /**\n     * The source code split into lines according to ECMA-262 specification.\n     * This is done to avoid each rule needing to do so separately.\n     * @type string[]\n     */\n    this.lines = text.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/g);\n\n    // create token store methods\n    var tokenStore = createTokenStore(ast.tokens);\n    Object.keys(tokenStore).forEach(function(methodName) {\n        this[methodName] = tokenStore[methodName];\n    }, this);\n\n    // don't allow modification of this object\n    Object.freeze(this);\n    Object.freeze(this.lines);\n}\n\nSourceCode.prototype = {\n    constructor: SourceCode,\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode=} node The AST node to get the text for.\n     * @param {int=} beforeCount The number of characters before the node to retrieve.\n     * @param {int=} afterCount The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     */\n    getText: function(node, beforeCount, afterCount) {\n        if (node) {\n            return (this.text !== null) ? this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0)) : null;\n        } else {\n            return this.text;\n        }\n\n    },\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     */\n    getLines: function() {\n        return this.lines;\n    },\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     */\n    getAllComments: function() {\n        return this.ast.comments;\n    },\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} The list of comments indexed by their position.\n     * @public\n     */\n    getComments: function(node) {\n\n        var leadingComments = node.leadingComments || [],\n            trailingComments = node.trailingComments || [];\n\n        /*\n         * espree adds a \"comments\" array on Program nodes rather than\n         * leadingComments/trailingComments. Comments are only left in the\n         * Program node comments array if there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                leadingComments = node.comments;\n            }\n        }\n\n        return {\n            leading: leadingComments,\n            trailing: trailingComments\n        };\n    },\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {ASTNode} The BlockComment node containing the JSDoc for the\n     *      given node or null if not found.\n     * @public\n     */\n    getJSDocComment: function(node) {\n\n        var parent = node.parent,\n            line = node.loc.start.line;\n\n        switch (node.type) {\n            case \"FunctionDeclaration\":\n                if (looksLikeExport(parent)) {\n                    return findJSDocComment(parent.leadingComments, line);\n                } else {\n                    return findJSDocComment(node.leadingComments, line);\n                }\n                break;\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (parent && !parent.leadingComments && !/Function/.test(parent.type)) {\n                        parent = parent.parent;\n                    }\n\n                    return parent && (parent.type !== \"FunctionDeclaration\") ? findJSDocComment(parent.leadingComments, line) : null;\n                }\n\n            // falls through\n\n            default:\n                return null;\n        }\n    },\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     */\n    getNodeByRangeIndex: function(index) {\n        var result = null;\n\n        estraverse.traverse(this.ast, {\n            enter: function(node, parent) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = assign({ parent: parent }, node);\n                } else {\n                    this.skip();\n                }\n            },\n            leave: function(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result;\n    },\n\n    /**\n     * Determines if two tokens have at least one whitespace character\n     * between them. This completely disregards comments in making the\n     * determination, so comments count as zero-length substrings.\n     * @param {Token} first The token to check after.\n     * @param {Token} second The token to check before.\n     * @returns {boolean} True if there is only space between tokens, false\n     *  if there is anything other than whitespace between tokens.\n     */\n    isSpaceBetweenTokens: function(first, second) {\n        var text = this.text.slice(first.range[1], second.range[0]);\n        return /\\s/.test(text.replace(/\\/\\*.*?\\*\\//g, \"\"));\n    }\n};\n\n\nmodule.exports = SourceCode;\n"]}