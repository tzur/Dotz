{"version":3,"sources":["callback-return.js"],"names":[],"mappings":"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","file":"callback-return-compiled.js","sourcesContent":["/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n * @copyright 2015 Jamund Ferguson. All rights reserved.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"];\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Find the closest parent matching a list of types.\n     * @param {ASTNode} node The node whose parents we are searching\n     * @param {Array} types The node types to match\n     * @returns {ASTNode} The matched node or undefined.\n     */\n    function findClosestParentOfType(node, types) {\n        if (!node.parent) {\n            return null;\n        }\n        if (types.indexOf(node.parent.type) === -1) {\n            return findClosestParentOfType(node.parent, types);\n        }\n        return node.parent;\n    }\n\n    /**\n     * Check to see if a CallExpression is in our callback list.\n     * @param {ASTNode} node The node to check against our callback names list.\n     * @returns {Boolean} Whether or not this function matches our callback name.\n     */\n    function isCallback(node) {\n        return node.callee.type === \"Identifier\" && callbacks.indexOf(node.callee.name) > -1;\n    }\n\n    /**\n     * Determines whether or not the callback is part of a callback expression.\n     * @param {ASTNode} node The callback node\n     * @param {ASTNode} parentNode The expression node\n     * @returns {boolean} Whether or not this is part of a callback expression\n     */\n    function isCallbackExpression(node, parentNode) {\n\n        // ensure the parent node exists and is an expression\n        if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n            return false;\n        }\n\n        // cb()\n        if (parentNode.expression === node) {\n            return true;\n        }\n\n        // special case for cb && cb() and similar\n        if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n            if (parentNode.expression.right === node) {\n                return true;\n            }\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        \"CallExpression\": function(node) {\n\n            // if we\"re not a callback we can return\n            if (!isCallback(node)) {\n                return;\n            }\n\n            // find the closest block, return or loop\n            var closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {},\n                lastItem, parentType;\n\n            // if our parent is a return we know we're ok\n            if (closestBlock.type === \"ReturnStatement\" ) {\n                return;\n            }\n\n            // arrow functions don't always have blocks and implicitly return\n            if (closestBlock.type === \"ArrowFunctionExpression\") {\n                return;\n            }\n\n            // block statements are part of functions and most if statements\n            if (closestBlock.type === \"BlockStatement\") {\n\n                // find the last item in the block\n                lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n                // if the callback is the last thing in a block that might be ok\n                if (isCallbackExpression(node, lastItem)) {\n\n                    parentType = closestBlock.parent.type;\n\n                    // but only if the block is part of a function\n                    if (parentType === \"FunctionExpression\" ||\n                        parentType === \"FunctionDeclaration\" ||\n                        parentType === \"ArrowFunctionExpression\"\n                    ) {\n                        return;\n                    }\n\n                }\n\n                // ending a block with a return is also ok\n                if (lastItem.type === \"ReturnStatement\") {\n\n                    // but only if the callback is immediately before\n                    if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n                        return;\n                    }\n                }\n\n            }\n\n            // as long as you're the child of a function at this point you should be asked to return\n            if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                context.report(node, \"Expected return with your callback function.\");\n            }\n\n        }\n\n    };\n};\n\nmodule.exports.schema = [{\n    type: \"array\",\n    items: { type: \"string\" }\n}];\n"]}