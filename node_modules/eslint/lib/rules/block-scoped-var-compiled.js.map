{"version":3,"sources":["block-scoped-var.js"],"names":[],"mappings":"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","file":"block-scoped-var-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * @copyright 2015 Mathieu M-Gosselin. All rights reserved.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Collects unresolved references from the global scope, then creates a map to references from its name.\n * @param {RuleContext} context - The current context.\n * @returns {object} A map object. Its key is the variable names. Its value is the references of each variable.\n */\nfunction collectUnresolvedReferences(context) {\n    var unresolved = Object.create(null);\n    var references = context.getScope().through;\n\n    for (var i = 0; i < references.length; ++i) {\n        var reference = references[i];\n        var name = reference.identifier.name;\n\n        if (name in unresolved === false) {\n            unresolved[name] = [];\n        }\n        unresolved[name].push(reference);\n    }\n\n    return unresolved;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    var unresolvedReferences = Object.create(null);\n    var stack = [];\n\n    /**\n     * Makes a block scope.\n     * @param {ASTNode} node - A node of a scope.\n     * @returns {void}\n     */\n    function enterScope(node) {\n        stack.push(node.range);\n    }\n\n    /**\n     * Pops the last block scope.\n     * @returns {void}\n     */\n    function exitScope() {\n        stack.pop();\n    }\n\n    /**\n     * Reports a given reference.\n     * @param {escope.Reference} reference - A reference to report.\n     * @returns {void}\n     */\n    function report(reference) {\n        var identifier = reference.identifier;\n        context.report(\n            identifier,\n            \"\\\"{{name}}\\\" used outside of binding context.\",\n            {name: identifier.name});\n    }\n\n    /**\n     * Finds and reports references which are outside of valid scopes.\n     * @param {ASTNode} node - A node to get variables.\n     * @returns {void}\n     */\n    function checkForVariables(node) {\n        if (node.kind !== \"var\") {\n            return;\n        }\n\n        var isGlobal = context.getScope().type === \"global\";\n\n        // Defines a predicate to check whether or not a given reference is outside of valid scope.\n        var scopeRange = stack[stack.length - 1];\n\n        /**\n         * Check if a reference is out of scope\n         * @param {ASTNode} reference node to examine\n         * @returns {boolean} True is its outside the scope\n         * @private\n         */\n        function isOutsideOfScope(reference) {\n            var idRange = reference.identifier.range;\n            return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n        }\n\n        // Gets declared variables, and checks its references.\n        var variables = context.getDeclaredVariables(node);\n        for (var i = 0; i < variables.length; ++i) {\n            var variable = variables[i];\n            var references = variable.references;\n\n            // Global variables are not resolved.\n            // In this case, use unresolved references.\n            if (isGlobal && variable.name in unresolvedReferences) {\n                references = unresolvedReferences[variable.name];\n            }\n\n            // Reports.\n            references.filter(isOutsideOfScope).forEach(report);\n        }\n    }\n\n    return {\n        \"Program\": function(node) {\n            unresolvedReferences = collectUnresolvedReferences(context);\n            stack = [node.range];\n        },\n\n        // Manages scopes.\n        \"BlockStatement\": enterScope,\n        \"BlockStatement:exit\": exitScope,\n        \"ForStatement\": enterScope,\n        \"ForStatement:exit\": exitScope,\n        \"ForInStatement\": enterScope,\n        \"ForInStatement:exit\": exitScope,\n        \"ForOfStatement\": enterScope,\n        \"ForOfStatement:exit\": exitScope,\n        \"SwitchStatement\": enterScope,\n        \"SwitchStatement:exit\": exitScope,\n        \"CatchClause\": enterScope,\n        \"CatchClause:exit\": exitScope,\n\n        // Finds and reports references which are outside of valid scope.\n        \"VariableDeclaration\": checkForVariables\n    };\n\n};\n\nmodule.exports.schema = [];\n"]}