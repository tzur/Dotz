{"version":3,"sources":["semi.js"],"names":[],"mappings":"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","file":"semi-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag missing semicolons.\n * @author Nicholas C. Zakas\n * @copyright 2013 Nicholas C. Zakas. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var OPT_OUT_PATTERN = /[\\[\\(\\/\\+\\-]/; // One of [(/+-\n\n    var always = context.options[0] !== \"never\",\n        sourceCode = context.getSourceCode();\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Reports a semicolon error with appropriate location and message.\n     * @param {ASTNode} node The node with an extra or missing semicolon.\n     * @returns {void}\n     */\n    function report(node) {\n        var message,\n            fix,\n            lastToken = sourceCode.getLastToken(node),\n            loc = lastToken.loc;\n\n        if (always) {\n            message = \"Missing semicolon.\";\n            loc = loc.end;\n            fix = function(fixer) {\n                return fixer.insertTextAfter(lastToken, \";\");\n            };\n        } else {\n            message = \"Extra semicolon.\";\n            loc = loc.start;\n            fix = function(fixer) {\n                return fixer.remove(lastToken);\n            };\n        }\n\n        context.report({\n            node: node,\n            loc: loc,\n            message: message,\n            fix: fix\n        });\n\n    }\n\n    /**\n     * Checks whether a token is a semicolon punctuator.\n     * @param {Token} token The token.\n     * @returns {boolean} True if token is a semicolon punctuator.\n     */\n    function isSemicolon(token) {\n        return (token.type === \"Punctuator\" && token.value === \";\");\n    }\n\n    /**\n     * Check if a semicolon is unnecessary, only true if:\n     *   - next token is on a new line and is not one of the opt-out tokens\n     *   - next token is a valid statement divider\n     * @param {Token} lastToken last token of current node.\n     * @returns {boolean} whether the semicolon is unnecessary.\n     */\n    function isUnnecessarySemicolon(lastToken) {\n        var isDivider, isOptOutToken, lastTokenLine, nextToken, nextTokenLine;\n\n        if (!isSemicolon(lastToken)) {\n            return false;\n        }\n\n        nextToken = context.getTokenAfter(lastToken);\n\n        if (!nextToken) {\n            return true;\n        }\n\n        lastTokenLine = lastToken.loc.end.line;\n        nextTokenLine = nextToken.loc.start.line;\n        isOptOutToken = OPT_OUT_PATTERN.test(nextToken.value);\n        isDivider = (nextToken.value === \"}\" || nextToken.value === \";\");\n\n        return (lastTokenLine !== nextTokenLine && !isOptOutToken) || isDivider;\n    }\n\n    /**\n     * Checks a node to see if it's followed by a semicolon.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n    function checkForSemicolon(node) {\n        var lastToken = context.getLastToken(node);\n\n        if (always) {\n            if (!isSemicolon(lastToken)) {\n                report(node);\n            }\n        } else {\n            if (isUnnecessarySemicolon(lastToken)) {\n                report(node);\n            }\n        }\n    }\n\n    /**\n     * Checks to see if there's a semicolon after a variable declaration.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n    function checkForSemicolonForVariableDeclaration(node) {\n        var ancestors = context.getAncestors(),\n            parentIndex = ancestors.length - 1,\n            parent = ancestors[parentIndex];\n\n        if ((parent.type !== \"ForStatement\" || parent.init !== node) &&\n            (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)\n        ) {\n            checkForSemicolon(node);\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n\n        \"VariableDeclaration\": checkForSemicolonForVariableDeclaration,\n        \"ExpressionStatement\": checkForSemicolon,\n        \"ReturnStatement\": checkForSemicolon,\n        \"ThrowStatement\": checkForSemicolon,\n        \"DoWhileStatement\": checkForSemicolon,\n        \"DebuggerStatement\": checkForSemicolon,\n        \"BreakStatement\": checkForSemicolon,\n        \"ContinueStatement\": checkForSemicolon,\n        \"ImportDeclaration\": checkForSemicolon,\n        \"ExportAllDeclaration\": checkForSemicolon,\n        \"ExportNamedDeclaration\": function(node) {\n            if (!node.declaration) {\n                checkForSemicolon(node);\n            }\n        },\n        \"ExportDefaultDeclaration\": function(node) {\n            if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {\n                checkForSemicolon(node);\n            }\n        }\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"always\", \"never\"]\n    }\n];\n"]}