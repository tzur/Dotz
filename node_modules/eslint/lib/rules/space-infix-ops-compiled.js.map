{"version":3,"sources":["space-infix-ops.js"],"names":[],"mappings":"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","file":"space-infix-ops-compiled.js","sourcesContent":["/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    var int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n\n    var OPERATORS = [\n        \"*\", \"/\", \"%\", \"+\", \"-\", \"<<\", \">>\", \">>>\", \"<\", \"<=\", \">\", \">=\", \"in\",\n        \"instanceof\", \"==\", \"!=\", \"===\", \"!==\", \"&\", \"^\", \"|\", \"&&\", \"||\", \"=\",\n        \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"&=\", \"^=\", \"|=\",\n        \"?\", \":\", \",\"\n    ];\n\n    /**\n     * Returns the first token which violates the rule\n     * @param {ASTNode} left - The left node of the main node\n     * @param {ASTNode} right - The right node of the main node\n     * @returns {object} The violator token or null\n     * @private\n     */\n    function getFirstNonSpacedToken(left, right) {\n        var op, tokens = context.getTokensBetween(left, right, 1);\n        for (var i = 1, l = tokens.length - 1; i < l; ++i) {\n            op = tokens[i];\n            if (\n                op.type === \"Punctuator\" &&\n                OPERATORS.indexOf(op.value) >= 0 &&\n                (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])\n            ) {\n                return op;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Reports an AST node as a rule violation\n     * @param {ASTNode} mainNode - The node to report\n     * @param {object} culpritToken - The token which has a problem\n     * @returns {void}\n     * @private\n     */\n    function report(mainNode, culpritToken) {\n        context.report({\n            node: mainNode,\n            loc: culpritToken.loc.start,\n            message: \"Infix operators must be spaced.\",\n            fix: function(fixer) {\n                var previousToken = context.getTokenBefore(culpritToken);\n                var afterToken = context.getTokenAfter(culpritToken);\n                var fixString = \"\";\n\n                if (culpritToken.range[0] - previousToken.range[1] === 0) {\n                    fixString = \" \";\n                }\n\n                fixString += culpritToken.value;\n\n                if (afterToken.range[0] - culpritToken.range[1] === 0) {\n                    fixString += \" \";\n                }\n\n                return fixer.replaceText(culpritToken, fixString);\n            }\n        });\n    }\n\n    /**\n     * Check if the node is binary then report\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkBinary(node) {\n        var nonSpacedNode = getFirstNonSpacedToken(node.left, node.right);\n\n        if (nonSpacedNode) {\n            if (!(int32Hint && context.getSource(node).substr(-2) === \"|0\")) {\n                report(node, nonSpacedNode);\n            }\n        }\n    }\n\n    /**\n     * Check if the node is conditional\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkConditional(node) {\n        var nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);\n        var nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);\n\n        if (nonSpacedConsequesntNode) {\n            report(node, nonSpacedConsequesntNode);\n        } else if (nonSpacedAlternateNode) {\n            report(node, nonSpacedAlternateNode);\n        }\n    }\n\n    /**\n     * Check if the node is a variable\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function checkVar(node) {\n        var nonSpacedNode;\n\n        if (node.init) {\n            nonSpacedNode = getFirstNonSpacedToken(node.id, node.init);\n            if (nonSpacedNode) {\n                report(node, nonSpacedNode);\n            }\n        }\n    }\n\n    return {\n        \"AssignmentExpression\": checkBinary,\n        \"AssignmentPattern\": checkBinary,\n        \"BinaryExpression\": checkBinary,\n        \"LogicalExpression\": checkBinary,\n        \"ConditionalExpression\": checkConditional,\n        \"VariableDeclarator\": checkVar\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"int32Hint\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}