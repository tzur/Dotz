{"version":3,"sources":["constructor-super.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;;;;;;AAO/B,aAAS,kBAAkB,CAAC,IAAI,EAAE;AAC9B,eAAO,IAAI,EAAE;AACT,gBAAI,IAAI,CAAC,IAAI,KAAK,kBAAkB,IAAI,IAAI,CAAC,IAAI,KAAK,iBAAiB,EAAE;AACrE,uBAAO,IAAI,CAAC;aACf;AACD,gBAAI,GAAG,IAAI,CAAC,MAAM,CAAC;SACtB;;AAED,eAAO,IAAI,CAAC;KACf;;;;;;;AAOD,aAAS,aAAa,CAAC,IAAI,EAAE;AACzB,eAAO,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC;KACjE;;;;;;;AAOD,aAAS,eAAe,CAAC,IAAI,EAAE;AAC3B,eAAO,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,OAAO,CAAC,QAAQ,EAAE,CAAC,aAAa,CAAC,KAAK,CAAC,aAAa,CAAC;KACtF;;;AAGD,QAAI,KAAK,GAAG,EAAE,CAAC;;AAEf,WAAO;;;;;;AAMH,0BAAkB,EAAE,0BAAS,IAAI,EAAE;AAC/B,gBAAI,IAAI,CAAC,IAAI,KAAK,aAAa,EAAE;AAC7B,uBAAO;aACV;AACD,iBAAK,CAAC,IAAI,CAAC;AACP,6BAAa,EAAE,EAAE;AACjB,qBAAK,EAAE,OAAO,CAAC,QAAQ,EAAE,CAAC,aAAa;aAC1C,CAAC,CAAC;SACN;;;;;;;AAOD,+BAAuB,EAAE,8BAAS,IAAI,EAAE;AACpC,gBAAI,IAAI,CAAC,IAAI,KAAK,aAAa,EAAE;AAC7B,uBAAO;aACV;AACD,gBAAI,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;;AAEzB,gBAAI,SAAS,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;;AAEzC,gBAAI,CAAC,SAAS,EAAE;AACZ,uBAAO;aACV;;AAED,gBAAI,SAAS,CAAC,UAAU,KAAK,IAAI,IAAI,aAAa,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE;AACtE,sBAAM,CAAC,aAAa,CAAC,OAAO,CAAC,UAAS,YAAY,EAAE;AAChD,2BAAO,CAAC,MAAM,CAAC,YAAY,EAAE,uBAAuB,CAAC,CAAC;iBACzD,CAAC,CAAC;aACN,MAAM,IAAI,MAAM,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;AAC1C,uBAAO,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,sCAAsC,CAAC,CAAC;aACpE;SACJ;;;;;;;AAOD,wBAAgB,EAAE,wBAAS,IAAI,EAAE;AAC7B,gBAAI,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACnC,gBAAI,eAAe,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,OAAO,EAAE;AACvD,oBAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACjC;SACJ;KACJ,CAAC;CACL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"constructor-super-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    /**\n     * Searches a class node from ancestors of a node.\n     * @param {Node} node - A node to get.\n     * @returns {ClassDeclaration|ClassExpression|null} the found class node or `null`.\n     */\n    function getClassInAncestor(node) {\n        while (node) {\n            if (node.type === \"ClassDeclaration\" || node.type === \"ClassExpression\") {\n                return node;\n            }\n            node = node.parent;\n        }\n        /* istanbul ignore next */\n        return null;\n    }\n\n    /**\n     * Checks whether or not a node is the null literal.\n     * @param {Node} node - A node to check.\n     * @returns {boolean} whether or not a node is the null literal.\n     */\n    function isNullLiteral(node) {\n        return node && node.type === \"Literal\" && node.value === null;\n    }\n\n    /**\n     * Checks whether or not the current traversal context is on constructors.\n     * @param {{scope: Scope}} item - A checking context to check.\n     * @returns {boolean} whether or not the current traversal context is on constructors.\n     */\n    function isOnConstructor(item) {\n        return item && item.scope === context.getScope().variableScope.upper.variableScope;\n    }\n\n    // A stack for checking context.\n    var stack = [];\n\n    return {\n        /**\n         * Start checking.\n         * @param {MethodDefinition} node - A target node.\n         * @returns {void}\n         */\n        \"MethodDefinition\": function(node) {\n            if (node.kind !== \"constructor\") {\n                return;\n            }\n            stack.push({\n                superCallings: [],\n                scope: context.getScope().variableScope\n            });\n        },\n\n        /**\n         * Checks the result, then reports invalid/missing `super()`.\n         * @param {MethodDefinition} node - A target node.\n         * @returns {void}\n         */\n        \"MethodDefinition:exit\": function(node) {\n            if (node.kind !== \"constructor\") {\n                return;\n            }\n            var result = stack.pop();\n\n            var classNode = getClassInAncestor(node);\n            /* istanbul ignore if */\n            if (!classNode) {\n                return;\n            }\n\n            if (classNode.superClass === null || isNullLiteral(classNode.superClass)) {\n                result.superCallings.forEach(function(superCalling) {\n                    context.report(superCalling, \"unexpected `super()`.\");\n                });\n            } else if (result.superCallings.length === 0) {\n                context.report(node.key, \"this constructor requires `super()`.\");\n            }\n        },\n\n        /**\n         * Checks the result of checking, then reports invalid/missing `super()`.\n         * @param {MethodDefinition} node - A target node.\n         * @returns {void}\n         */\n        \"CallExpression\": function(node) {\n            var item = stack[stack.length - 1];\n            if (isOnConstructor(item) && node.callee.type === \"Super\") {\n                item.superCallings.push(node);\n            }\n        }\n    };\n};\n\nmodule.exports.schema = [];\n"]}