{"version":3,"sources":["operator-linebreak.js"],"names":[],"mappings":"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","file":"operator-linebreak-compiled.js","sourcesContent":["/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n * @copyright 2015 Benoît Zugmeyer. All rights reserved.\n */\n\n\"use strict\";\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var usedDefaultGlobal = !context.options[0];\n    var globalStyle = context.options[0] || \"after\";\n    var options = context.options[1] || {};\n    var styleOverrides = options.overrides || {};\n\n    if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n        styleOverrides[\"?\"] = \"before\";\n    }\n\n    if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n        styleOverrides[\":\"] = \"before\";\n    }\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks the operator placement\n     * @param {ASTNode} node The node to check\n     * @param {ASTNode} leftSide The node that comes before the operator in `node`\n     * @private\n     * @returns {void}\n     */\n    function validateNode(node, leftSide) {\n        var leftToken = context.getLastToken(leftSide);\n        var operatorToken = context.getTokenAfter(leftToken);\n\n        // When the left part of a binary expression is a single expression wrapped in\n        // parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n        // and operatorToken will be the closing parenthesis.\n        // The leftToken should be the last closing parenthesis, and the operatorToken\n        // should be the token right after that.\n        while (operatorToken.value === \")\") {\n            leftToken = operatorToken;\n            operatorToken = context.getTokenAfter(operatorToken);\n        }\n\n        var rightToken = context.getTokenAfter(operatorToken);\n        var operator = operatorToken.value;\n        var style = styleOverrides[operator] || globalStyle;\n\n        // if single line\n        if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n            return;\n\n        } else if (!astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n            // lone operator\n            context.report(node, {\n                line: operatorToken.loc.end.line,\n                column: operatorToken.loc.end.column\n            }, \"Bad line breaking before and after '\" + operator + \"'.\");\n\n        } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n            context.report(node, {\n                line: operatorToken.loc.end.line,\n                column: operatorToken.loc.end.column\n            }, \"'\" + operator + \"' should be placed at the beginning of the line.\");\n\n        } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n            context.report(node, {\n                line: operatorToken.loc.end.line,\n                column: operatorToken.loc.end.column\n            }, \"'\" + operator + \"' should be placed at the end of the line.\");\n\n        } else if (style === \"none\") {\n\n            context.report(node, {\n                line: operatorToken.loc.end.line,\n                column: operatorToken.loc.end.column\n            }, \"There should be no line break before or after '\" + operator + \"'\");\n\n        }\n    }\n\n    /**\n     * Validates a binary expression using `validateNode`\n     * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n     * @returns {void}\n     */\n    function validateBinaryExpression(node) {\n        validateNode(node, node.left);\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        \"BinaryExpression\": validateBinaryExpression,\n        \"LogicalExpression\": validateBinaryExpression,\n        \"AssignmentExpression\": validateBinaryExpression,\n        \"VariableDeclarator\": function(node) {\n            if (node.init) {\n                validateNode(node, node.id);\n            }\n        },\n        \"ConditionalExpression\": function(node) {\n            validateNode(node, node.test);\n            validateNode(node, node.consequent);\n        }\n    };\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"after\", \"before\", \"none\", null]\n    },\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"overrides\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"anyOf\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"after\", \"before\", \"none\"]\n                    }\n                }\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}