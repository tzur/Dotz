{"version":3,"sources":["no-use-before-define.js"],"names":[],"mappings":"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","file":"no-use-before-define-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n * @copyright 2013 Ilya Volodin. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nvar NO_FUNC = \"nofunc\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    /**\n     * Finds variable declarations in a given scope.\n     * @param {string} name The variable name to find.\n     * @param {Scope} scope The scope to search in.\n     * @returns {Object} The variable declaration object.\n     * @private\n     */\n    function findDeclaration(name, scope) {\n        // try searching in the current scope first\n        for (var i = 0, l = scope.variables.length; i < l; i++) {\n            if (scope.variables[i].name === name) {\n                return scope.variables[i];\n            }\n        }\n        // check if there's upper scope and call recursivly till we find the variable\n        if (scope.upper) {\n            return findDeclaration(name, scope.upper);\n        }\n    }\n\n    /**\n     * Finds and validates all variables in a given scope.\n     * @param {Scope} scope The scope object.\n     * @returns {void}\n     * @private\n     */\n    function findVariablesInScope(scope) {\n        var typeOption = context.options[0];\n\n        /**\n         * Report the node\n         * @param {object} reference reference object\n         * @param {ASTNode} declaration node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkLocationAndReport(reference, declaration) {\n            if (typeOption !== NO_FUNC || declaration.defs[0].type !== \"FunctionName\") {\n                if (declaration.identifiers[0].range[1] > reference.identifier.range[1]) {\n                    context.report(reference.identifier, \"{{a}} was used before it was defined\", {a: reference.identifier.name});\n                }\n            }\n        }\n\n        scope.references.forEach(function(reference) {\n            // if the reference is resolved check for declaration location\n            // if not, it could be function invocation, try to find manually\n            if (reference.resolved && reference.resolved.identifiers.length > 0) {\n                checkLocationAndReport(reference, reference.resolved);\n            } else {\n                var declaration = findDeclaration(reference.identifier.name, scope);\n                // if there're no identifiers, this is a global environment variable\n                if (declaration && declaration.identifiers.length !== 0) {\n                    checkLocationAndReport(reference, declaration);\n                }\n            }\n        });\n    }\n\n\n    /**\n     * Validates variables inside of a node's scope.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     * @private\n     */\n    function findVariables() {\n        var scope = context.getScope();\n        findVariablesInScope(scope);\n    }\n\n    var ruleDefinition = {\n        \"Program\": function() {\n            var scope = context.getScope();\n            findVariablesInScope(scope);\n\n            // both Node.js and Modules have an extra scope\n            if (context.ecmaFeatures.globalReturn || context.ecmaFeatures.modules) {\n                findVariablesInScope(scope.childScopes[0]);\n            }\n        }\n    };\n\n    if (context.ecmaFeatures.blockBindings) {\n        ruleDefinition.BlockStatement = ruleDefinition.SwitchStatement = findVariables;\n\n        ruleDefinition.ArrowFunctionExpression = function(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                findVariables(node);\n            }\n        };\n    } else {\n        ruleDefinition.FunctionExpression = ruleDefinition.FunctionDeclaration = ruleDefinition.ArrowFunctionExpression = findVariables;\n    }\n\n    return ruleDefinition;\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"nofunc\"]\n    }\n];\n"]}