{"version":3,"sources":["no-implied-eval.js"],"names":[],"mappings":"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","file":"no-implied-eval-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n * @copyright 2015 Mathias Schreck. All rights reserved.\n * @copyright 2013 James Allardice. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    var CALLEE_RE = /set(?:Timeout|Interval)|execScript/;\n\n    // Figures out if we should inspect a given binary expression. Is a stack of\n    // stacks, where the first element in each substack is a CallExpression.\n    var impliedEvalAncestorsStack = [];\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Get the last element of an array, without modifying arr, like pop(), but non-destructive.\n     * @param {array} arr What to inspect\n     * @returns {*} The last element of arr\n     * @private\n     */\n    function last(arr) {\n        return arr ? arr[arr.length - 1] : null;\n    }\n\n    /**\n     * Checks if the given MemberExpression node is a potentially implied eval identifier on window.\n     * @param {ASTNode} node The MemberExpression node to check.\n     * @returns {boolean} Whether or not the given node is potentially an implied eval.\n     * @private\n     */\n    function isImpliedEvalMemberExpression(node) {\n        var object = node.object,\n            property = node.property,\n            hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);\n\n        return object.name === \"window\" && hasImpliedEvalName;\n    }\n\n    /**\n     * Determines if a node represents a call to a potentially implied eval.\n     *\n     * This checks the callee name and that there's an argument, but not the type of the argument.\n     *\n     * @param {ASTNode} node The CallExpression to check.\n     * @returns {boolean} True if the node matches, false if not.\n     * @private\n     */\n    function isImpliedEvalCallExpression(node) {\n        var isMemberExpression = (node.callee.type === \"MemberExpression\"),\n            isIdentifier = (node.callee.type === \"Identifier\"),\n            isImpliedEvalCallee =\n                (isIdentifier && CALLEE_RE.test(node.callee.name)) ||\n                (isMemberExpression && isImpliedEvalMemberExpression(node.callee));\n\n        return isImpliedEvalCallee && node.arguments.length;\n    }\n\n    /**\n     * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.\n     * @param {ASTNode} node The node to inspect the parent of.\n     * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?\n     * @private\n     */\n    function hasImpliedEvalParent(node) {\n        // make sure our parent is marked\n        return node.parent === last(last(impliedEvalAncestorsStack)) &&\n            // if our parent is a CallExpression, make sure we're the first argument\n            (node.parent.type !== \"CallExpression\" || node === node.parent.arguments[0]);\n    }\n\n    /**\n     * Checks if our parent is marked as part of an implied eval argument. If\n     * so, collapses the top of impliedEvalAncestorsStack and reports on the\n     * original CallExpression.\n     * @param {ASTNode} node The CallExpression to check.\n     * @returns {boolean} True if the node matches, false if not.\n     * @private\n     */\n    function checkString(node) {\n        if (hasImpliedEvalParent(node)) {\n            // remove the entire substack, to avoid duplicate reports\n            var substack = impliedEvalAncestorsStack.pop();\n            context.report(substack[0], \"Implied eval. Consider passing a function instead of a string.\");\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        \"CallExpression\": function(node) {\n            if (isImpliedEvalCallExpression(node)) {\n                // call expressions create a new substack\n                impliedEvalAncestorsStack.push([node]);\n            }\n        },\n\n        \"CallExpression:exit\": function(node) {\n            if (node === last(last(impliedEvalAncestorsStack))) {\n                // destroys the entire sub-stack, rather than just using\n                // last(impliedEvalAncestorsStack).pop(), as a CallExpression is\n                // always the bottom of a impliedEvalAncestorsStack substack.\n                impliedEvalAncestorsStack.pop();\n            }\n        },\n\n        \"BinaryExpression\": function(node) {\n            if (node.operator === \"+\" && hasImpliedEvalParent(node)) {\n                last(impliedEvalAncestorsStack).push(node);\n            }\n        },\n\n        \"BinaryExpression:exit\": function(node) {\n            if (node === last(last(impliedEvalAncestorsStack))) {\n                last(impliedEvalAncestorsStack).pop();\n            }\n        },\n\n        \"Literal\": function(node) {\n            if (typeof node.value === \"string\") {\n                checkString(node);\n            }\n        },\n\n        \"TemplateLiteral\": function(node) {\n            checkString(node);\n        }\n    };\n\n};\n\nmodule.exports.schema = [];\n"]}