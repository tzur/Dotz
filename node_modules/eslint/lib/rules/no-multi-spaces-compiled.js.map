{"version":3,"sources":["no-multi-spaces.js"],"names":[],"mappings":"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","file":"no-multi-spaces-compiled.js","sourcesContent":["/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n * @copyright 2015 Brandon Mills. All rights reserved.\n * @copyright 2015 Nicholas C. Zakas. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    // the index of the last comment that was checked\n    var exceptions = { \"Property\": true },\n        hasExceptions = true,\n        options = context.options[0],\n        lastCommentIndex = 0;\n\n    if (options && options.exceptions) {\n        Object.keys(options.exceptions).forEach(function(key) {\n            if (options.exceptions[key]) {\n                exceptions[key] = true;\n            } else {\n                delete exceptions[key];\n            }\n        });\n        hasExceptions = Object.keys(exceptions).length > 0;\n    }\n\n    /**\n     * Determines if a given source index is in a comment or not by checking\n     * the index against the comment range. Since the check goes straight\n     * through the file, once an index is passed a certain comment, we can\n     * go to the next comment to check that.\n     * @param {int} index The source index to check.\n     * @param {ASTNode[]} comments An array of comment nodes.\n     * @returns {boolean} True if the index is within a comment, false if not.\n     * @private\n     */\n    function isIndexInComment(index, comments) {\n\n        var comment;\n\n        while (lastCommentIndex < comments.length) {\n\n            comment = comments[lastCommentIndex];\n\n            if (comment.range[0] <= index && index < comment.range[1]) {\n                return true;\n            } else if (index > comment.range[1]) {\n                lastCommentIndex++;\n            } else {\n                break;\n            }\n\n        }\n\n        return false;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        \"Program\": function() {\n\n            var source = context.getSource(),\n                allComments = context.getAllComments(),\n                pattern = /[^\\n\\r\\u2028\\u2029 ] {2,}/g,  // note: repeating space\n                token,\n                previousToken,\n                parent;\n\n\n            /**\n             * Creates a fix function that removes the multiple spaces between the two tokens\n             * @param {RuleFixer} leftToken left token\n             * @param {RuleFixer} rightToken right token\n             * @returns {function} fix function\n             * @private\n             */\n            function createFix(leftToken, rightToken) {\n                return function(fixer) {\n                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \");\n                };\n            }\n\n            while (pattern.test(source)) {\n\n                // do not flag anything inside of comments\n                if (!isIndexInComment(pattern.lastIndex, allComments)) {\n\n                    token = context.getTokenByRangeStart(pattern.lastIndex);\n                    if (token) {\n                        previousToken = context.getTokenBefore(token);\n\n                        if (hasExceptions) {\n                            parent = context.getNodeByRangeIndex(pattern.lastIndex - 1);\n                        }\n\n                        if (!parent || !exceptions[parent.type]) {\n                            context.report({\n                                node: token,\n                                loc: token.loc.start,\n                                message: \"Multiple spaces found before '{{value}}'.\",\n                                data: { value: token.value },\n                                fix: createFix(previousToken, token)\n                            });\n                        }\n                    }\n\n                }\n            }\n        }\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"exceptions\": {\n                \"type\": \"object\",\n                \"patternProperties\": {\n                    \"^([A-Z][a-z]*)+$\": {\n                        \"type\": \"boolean\"\n                    }\n                },\n                \"additionalProperties\": false\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}