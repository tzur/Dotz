{"version":3,"sources":["prefer-arrow-callback.js"],"names":[],"mappings":"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","file":"prefer-arrow-callback-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {escope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node - A MetaProperty node to check.\n * @param {string} metaName - The name of `MetaProperty.meta`.\n * @param {string} propertyName - The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    // TODO: Remove this if block after https://github.com/eslint/espree/issues/206 was fixed.\n    if (typeof node.meta === \"string\") {\n        return node.meta === metaName && node.property === propertyName;\n    }\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {escope.Scope} scope - A scope to get.\n * @returns {escope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    var variables = scope.variables;\n    for (var i = 0; i < variables.length; ++i) {\n        var variable = variables[i];\n        if (variable.name === \"arguments\") {\n            // If there was a parameter which is named \"arguments\", the implicit \"arguments\" is not defined.\n            // So does fast return with null.\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next */\n    return null;\n}\n\n/**\n * Checkes whether or not a given node is a callback.\n * @param {ASTNode} node - A node to check.\n * @returns {object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    var retv = {isCallback: false, isLexicalThis: false};\n    var parent = node.parent;\n    while (node) {\n        switch (parent.type) {\n            // Checks parents recursively.\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (parent.object === node &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\" &&\n                    parent.parent.type === \"CallExpression\" &&\n                    parent.parent.callee === parent\n                ) {\n                    retv.isLexicalThis = (\n                        parent.parent.arguments.length === 1 &&\n                        parent.parent.arguments[0].type === \"ThisExpression\"\n                    );\n                    node = parent;\n                    parent = parent.parent;\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== node) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        node = parent;\n        parent = parent.parent;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\"unreachable\");\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    // {Array<{this: boolean, super: boolean, meta: boolean}>}\n    // - this - A flag which shows there are one or more ThisExpression.\n    // - super - A flag which shows there are one or more Super.\n    // - meta - A flag which shows there are one or more MethProperty.\n    var stack = [];\n\n    /**\n     * Pushes new function scope with all `false` flags.\n     * @returns {void}\n     */\n    function enterScope() {\n        stack.push({this: false, super: false, meta: false});\n    }\n\n    /**\n     * Pops a function scope from the stack.\n     * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n     */\n    function exitScope() {\n        return stack.pop();\n    }\n\n    return {\n        // Reset internal state.\n        Program: function() {\n            stack = [];\n        },\n\n        // If there are below, it cannot replace with arrow functions merely.\n        ThisExpression: function() {\n            var info = stack[stack.length - 1];\n            if (info) {\n                info.this = true;\n            }\n        },\n        Super: function() {\n            var info = stack[stack.length - 1];\n            if (info) {\n                info.super = true;\n            }\n        },\n        MetaProperty: function(node) {\n            var info = stack[stack.length - 1];\n            if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                info.meta = true;\n            }\n        },\n\n        // To skip nested scopes.\n        FunctionDeclaration: enterScope,\n        \"FunctionDeclaration:exit\": exitScope,\n\n        // Main.\n        FunctionExpression: enterScope,\n        \"FunctionExpression:exit\": function(node) {\n            var scopeInfo = exitScope();\n\n            // Skip generators.\n            if (node.generator) {\n                return;\n            }\n\n            // Skip recursive functions.\n            var nameVar = context.getDeclaredVariables(node)[0];\n            if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                return;\n            }\n\n            // Skip if it's using arguments.\n            var variable = getVariableOfArguments(context.getScope());\n            if (variable && variable.references.length > 0) {\n                return;\n            }\n\n            // Reports if it's a callback which can replace with arrows.\n            var callbackInfo = getCallbackInfo(node);\n            if (callbackInfo.isCallback &&\n                (!scopeInfo.this || callbackInfo.isLexicalThis) &&\n                !scopeInfo.super &&\n                !scopeInfo.meta\n            ) {\n                context.report(node, \"Unexpected function expression.\");\n            }\n        }\n    };\n};\n\nmodule.exports.schema = [];\n"]}