{"version":3,"sources":["no-eq-null.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,WAAO;;AAEH,0BAAkB,EAAE,0BAAS,IAAI,EAAE;AAC/B,gBAAI,WAAW,GAAG,IAAI,CAAC,QAAQ,KAAK,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC;;AAEnE,gBAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,MAAM,IAAI,WAAW,IACrE,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,MAAM,IAAI,WAAW,EAAE;AAC7E,uBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,mCAAmC,CAAC,CAAC;aAC7D;SACJ;KACJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"no-eq-null-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag comparisons to null without a type-checking\n * operator.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    return {\n\n        \"BinaryExpression\": function(node) {\n            var badOperator = node.operator === \"==\" || node.operator === \"!=\";\n\n            if (node.right.type === \"Literal\" && node.right.raw === \"null\" && badOperator ||\n                    node.left.type === \"Literal\" && node.left.raw === \"null\" && badOperator) {\n                context.report(node, \"Use ‘===’ to compare with ‘null’.\");\n            }\n        }\n    };\n\n};\n\nmodule.exports.schema = [];\n"]}