{"version":3,"sources":["complexity.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,SAAS,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;;;;;;;AAOnC,QAAI,GAAG,GAAG,EAAE,CAAC;;;;;;;AAOb,aAAS,aAAa,GAAG;AACrB,WAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACf;;;;;;;;AAQD,aAAS,WAAW,CAAC,IAAI,EAAE;AACvB,YAAI,UAAU,GAAG,GAAG,CAAC,GAAG,EAAE;YACtB,IAAI,GAAG,WAAW,CAAC;;AAEvB,YAAI,IAAI,CAAC,EAAE,EAAE;AACT,gBAAI,GAAG,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC;SACvB,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,kBAAkB,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,UAAU,EAAE;AACnF,gBAAI,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC;SAC/B;;AAED,YAAI,UAAU,GAAG,SAAS,EAAE;AACxB,mBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,yDAAyD,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,CAAC,CAAC;SAC3H;KACJ;;;;;;;AAOD,aAAS,kBAAkB,GAAG;AAC1B,YAAI,GAAG,CAAC,MAAM,EAAE;AACZ,eAAG,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,EAAG,CAAC;SAC1B;KACJ;;;;;;;;AAQD,aAAS,wBAAwB,CAAC,IAAI,EAAE;;AAEpC,YAAI,IAAI,CAAC,IAAI,EAAE;AACX,8BAAkB,CAAC,IAAI,CAAC,CAAC;SAC5B;KACJ;;;;;;;;AAQD,aAAS,yBAAyB,CAAC,IAAI,EAAE;;AAErC,YAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,EAAE;AACxB,8BAAkB,CAAC,IAAI,CAAC,CAAC;SAC5B;KACJ;;;;;;AAMD,WAAO;AACH,6BAAqB,EAAE,aAAa;AACpC,4BAAoB,EAAE,aAAa;AACnC,iCAAyB,EAAE,aAAa;AACxC,kCAA0B,EAAE,WAAW;AACvC,iCAAyB,EAAE,WAAW;AACtC,sCAA8B,EAAE,WAAW;;AAE3C,qBAAa,EAAE,kBAAkB;AACjC,+BAAuB,EAAE,kBAAkB;AAC3C,2BAAmB,EAAE,yBAAyB;AAC9C,sBAAc,EAAE,kBAAkB;AAClC,wBAAgB,EAAE,kBAAkB;AACpC,wBAAgB,EAAE,kBAAkB;AACpC,qBAAa,EAAE,kBAAkB;AACjC,oBAAY,EAAE,wBAAwB;AACtC,wBAAgB,EAAE,kBAAkB;AACpC,0BAAkB,EAAE,kBAAkB;KACzC,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,SAAS;CACpB,CACJ,CAAC","file":"complexity-compiled.js","sourcesContent":["/**\n * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.\n * Counts the number of if, conditional, for, whilte, try, switch/case,\n * @author Patrick Brosset\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var THRESHOLD = context.options[0];\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    // Using a stack to store complexity (handling nested functions)\n    var fns = [];\n\n    /**\n     * When parsing a new function, store it in our function stack\n     * @returns {void}\n     * @private\n     */\n    function startFunction() {\n        fns.push(1);\n    }\n\n    /**\n     * Evaluate the node at the end of function\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function endFunction(node) {\n        var complexity = fns.pop(),\n            name = \"anonymous\";\n\n        if (node.id) {\n            name = node.id.name;\n        } else if (node.parent.type === \"MethodDefinition\" || node.parent.type === \"Property\") {\n            name = node.parent.key.name;\n        }\n\n        if (complexity > THRESHOLD) {\n            context.report(node, \"Function '{{name}}' has a complexity of {{complexity}}.\", { name: name, complexity: complexity });\n        }\n    }\n\n    /**\n     * Increase the complexity of the function in context\n     * @returns {void}\n     * @private\n     */\n    function increaseComplexity() {\n        if (fns.length) {\n            fns[fns.length - 1] ++;\n        }\n    }\n\n    /**\n     * Increase the switch complexity in context\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function increaseSwitchComplexity(node) {\n        // Avoiding `default`\n        if (node.test) {\n            increaseComplexity(node);\n        }\n    }\n\n    /**\n     * Increase the logical path complexity in context\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function increaseLogicalComplexity(node) {\n        // Avoiding &&\n        if (node.operator === \"||\") {\n            increaseComplexity(node);\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n        \"FunctionDeclaration\": startFunction,\n        \"FunctionExpression\": startFunction,\n        \"ArrowFunctionExpression\": startFunction,\n        \"FunctionDeclaration:exit\": endFunction,\n        \"FunctionExpression:exit\": endFunction,\n        \"ArrowFunctionExpression:exit\": endFunction,\n\n        \"CatchClause\": increaseComplexity,\n        \"ConditionalExpression\": increaseComplexity,\n        \"LogicalExpression\": increaseLogicalComplexity,\n        \"ForStatement\": increaseComplexity,\n        \"ForInStatement\": increaseComplexity,\n        \"ForOfStatement\": increaseComplexity,\n        \"IfStatement\": increaseComplexity,\n        \"SwitchCase\": increaseSwitchComplexity,\n        \"WhileStatement\": increaseComplexity,\n        \"DoWhileStatement\": increaseComplexity\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"integer\"\n    }\n];\n"]}