{"version":3,"sources":["no-extra-semi.js"],"names":[],"mappings":";;;;;AAKA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;;;;;;AAO/B,aAAS,MAAM,CAAC,WAAW,EAAE;AACzB,eAAO,CAAC,MAAM,CAAC;AACX,gBAAI,EAAE,WAAW;AACjB,mBAAO,EAAE,wBAAwB;AACjC,eAAG,EAAE,aAAS,KAAK,EAAE;AACjB,uBAAO,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;aACpC;SACJ,CAAC,CAAC;KACN;;;;;;;;;AASD,aAAS,uBAAuB,CAAC,UAAU,EAAE;AACzC,aAAK,IAAI,KAAK,GAAG,UAAU,EACvB,KAAK,CAAC,IAAI,KAAK,YAAY,IAAI,KAAK,CAAC,KAAK,KAAK,GAAG,EAClD,KAAK,GAAG,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,EACtC;AACE,gBAAI,KAAK,CAAC,KAAK,KAAK,GAAG,EAAE;AACrB,sBAAM,CAAC,KAAK,CAAC,CAAC;aACjB;SACJ;KACJ;;AAED,WAAO;;;;;;AAMH,wBAAgB,EAAE,wBAAS,IAAI,EAAE;AAC7B,gBAAI,MAAM,GAAG,IAAI,CAAC,MAAM;gBACpB,kBAAkB,GAAG,CAAC,cAAc,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,kBAAkB,CAAC,CAAC;;AAEpH,gBAAI,kBAAkB,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;AAChD,sBAAM,CAAC,IAAI,CAAC,CAAC;aAChB;SACJ;;;;;;;AAOD,mBAAW,EAAE,mBAAS,IAAI,EAAE;AACxB,mCAAuB,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;SAC3D;;;;;;;AAOD,0BAAkB,EAAE,0BAAS,IAAI,EAAE;AAC/B,mCAAuB,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;SACxD;KACJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"no-extra-semi-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag use of unnecessary semicolons\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    /**\n     * Reports an unnecessary semicolon error.\n     * @param {Node|Token} nodeOrToken - A node or a token to be reported.\n     * @returns {void}\n     */\n    function report(nodeOrToken) {\n        context.report({\n            node: nodeOrToken,\n            message: \"Unnecessary semicolon.\",\n            fix: function(fixer) {\n                return fixer.remove(nodeOrToken);\n            }\n        });\n    }\n\n    /**\n     * Checks for a part of a class body.\n     * This checks tokens from a specified token to a next MethodDefinition or the end of class body.\n     *\n     * @param {Token} firstToken - The first token to check.\n     * @returns {void}\n     */\n    function checkForPartOfClassBody(firstToken) {\n        for (var token = firstToken;\n            token.type === \"Punctuator\" && token.value !== \"}\";\n            token = context.getTokenAfter(token)\n        ) {\n            if (token.value === \";\") {\n                report(token);\n            }\n        }\n    }\n\n    return {\n        /**\n         * Reports this empty statement, except if the parent node is a loop.\n         * @param {Node} node - A EmptyStatement node to be reported.\n         * @returns {void}\n         */\n        \"EmptyStatement\": function(node) {\n            var parent = node.parent,\n                allowedParentTypes = [\"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"WhileStatement\", \"DoWhileStatement\"];\n\n            if (allowedParentTypes.indexOf(parent.type) === -1) {\n                report(node);\n            }\n        },\n\n        /**\n         * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.\n         * @param {Node} node - A ClassBody node to check.\n         * @returns {void}\n         */\n        \"ClassBody\": function(node) {\n            checkForPartOfClassBody(context.getFirstToken(node, 1)); // 0 is `{`.\n        },\n\n        /**\n         * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.\n         * @param {Node} node - A MethodDefinition node of the start point.\n         * @returns {void}\n         */\n        \"MethodDefinition\": function(node) {\n            checkForPartOfClassBody(context.getTokenAfter(node));\n        }\n    };\n\n};\n\nmodule.exports.schema = [];\n"]}