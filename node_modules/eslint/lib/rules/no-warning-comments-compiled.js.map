{"version":3,"sources":["no-warning-comments.js"],"names":[],"mappings":";;;;;AAKA,YAAY,CAAC;;AAEb,IAAI,QAAQ,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;;;;;;AAMvC,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,aAAa,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE;QACxC,YAAY,GAAG,aAAa,CAAC,KAAK,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,KAAK,CAAC;QAC9D,QAAQ,GAAG,aAAa,CAAC,QAAQ,IAAI,OAAO;QAC5C,eAAe,GAAG,yBAAyB;QAC3C,cAAc,CAAC;;;;;;;;;;AAUnB,aAAS,eAAe,CAAC,IAAI,EAAE;AAC3B,YAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,0BAA0B,EAAE,MAAM,CAAC;;;;;;;AAM1D,cAAM,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,GAAG,EAAE;YACtC,MAAM,CAAC;;AAEX,YAAI,QAAQ,KAAK,OAAO,EAAE;;AAEtB,kBAAM,GAAG,OAAO,CAAC;SACpB,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AACzB,kBAAM,GAAG,KAAK,CAAC;SAClB,MAAM;AACH,kBAAM,GAAG,EAAE,CAAC;SACf;;AAED,eAAO,IAAI,MAAM,CAAC,MAAM,GAAG,OAAO,GAAG,MAAM,EAAE,GAAG,CAAC,CAAC;KACrD;;;;;;;AAOD,aAAS,0BAA0B,CAAC,OAAO,EAAE;AACzC,YAAI,OAAO,GAAG,EAAE,CAAC;;AAEjB,sBAAc,CAAC,OAAO,CAAC,UAAS,KAAK,EAAE,KAAK,EAAE;AAC1C,gBAAI,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;AACrB,uBAAO,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;aACrC;SACJ,CAAC,CAAC;;AAEH,eAAO,OAAO,CAAC;KAClB;;;;;;;AAOD,aAAS,YAAY,CAAC,IAAI,EAAE;AACxB,YAAI,QAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;AACvE,mBAAO;SACV;;AAED,YAAI,OAAO,GAAG,0BAA0B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;;AAErD,eAAO,CAAC,OAAO,CAAC,UAAS,WAAW,EAAE;AAClC,mBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,aAAa,GAAG,WAAW,GAAG,WAAW,CAAC,CAAC;SACnE,CAAC,CAAC;KACN;;AAED,kBAAc,GAAG,YAAY,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;AACnD,WAAO;AACH,sBAAc,EAAE,YAAY;AAC5B,qBAAa,EAAE,YAAY;KAC9B,CAAC;CACL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,QAAQ;AAChB,gBAAY,EAAE;AACV,eAAO,EAAE;AACL,kBAAM,EAAE,OAAO;AACf,mBAAO,EAAE;AACL,sBAAM,EAAE,QAAQ;aACnB;SACJ;AACD,kBAAU,EAAE;AACR,kBAAM,EAAE,CAAC,OAAO,EAAE,UAAU,CAAC;SAChC;KACJ;AACD,0BAAsB,EAAE,KAAK;CAChC,CACJ,CAAC","file":"no-warning-comments-compiled.js","sourcesContent":["/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var configuration = context.options[0] || {},\n        warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n        location = configuration.location || \"start\",\n        selfConfigRegEx = /\\bno-warning-comments\\b/,\n        warningRegExps;\n\n    /**\n     * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n     * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n     * require word boundaries on that side.\n     *\n     * @param {String} term A term to convert to a RegExp\n     * @returns {RegExp} The term converted to a RegExp\n     */\n    function convertToRegExp(term) {\n        var escaped = term.replace(/[-\\/\\\\$\\^*+?.()|\\[\\]{}]/g, \"\\\\$&\"),\n            // If the term ends in a word character (a-z0-9_), ensure a word boundary at the end, so that substrings do\n            // not get falsely matched. eg \"todo\" in a string such as \"mastodon\".\n            // If the term ends in a non-word character, then \\b won't match on the boundary to the next non-word\n            // character, which would likely be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n            // In these cases, use no bounding match. Same applies for the prefix, handled below.\n            suffix = /\\w$/.test(term) ? \"\\\\b\" : \"\",\n            prefix;\n\n        if (location === \"start\") {\n            // When matching at the start, ignore leading whitespace, and there's no need to worry about word boundaries\n            prefix = \"^\\\\s*\";\n        } else if (/^\\w/.test(term)) {\n            prefix = \"\\\\b\";\n        } else {\n            prefix = \"\";\n        }\n\n        return new RegExp(prefix + escaped + suffix, \"i\");\n    }\n\n    /**\n     * Checks the specified comment for matches of the configured warning terms and returns the matches.\n     * @param {String} comment The comment which is checked.\n     * @returns {Array} All matched warning terms for this comment.\n     */\n    function commentContainsWarningTerm(comment) {\n        var matches = [];\n\n        warningRegExps.forEach(function(regex, index) {\n            if (regex.test(comment)) {\n                matches.push(warningTerms[index]);\n            }\n        });\n\n        return matches;\n    }\n\n    /**\n     * Checks the specified node for matching warning comments and reports them.\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {void} undefined.\n     */\n    function checkComment(node) {\n        if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {\n            return;\n        }\n\n        var matches = commentContainsWarningTerm(node.value);\n\n        matches.forEach(function(matchedTerm) {\n            context.report(node, \"Unexpected \" + matchedTerm + \" comment.\");\n        });\n    }\n\n    warningRegExps = warningTerms.map(convertToRegExp);\n    return {\n        \"BlockComment\": checkComment,\n        \"LineComment\": checkComment\n    };\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"terms\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"string\"\n                }\n            },\n            \"location\": {\n                \"enum\": [\"start\", \"anywhere\"]\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}