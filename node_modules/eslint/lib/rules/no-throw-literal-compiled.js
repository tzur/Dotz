/**
 * @fileoverview Rule to restrict what can be thrown as an exception.
 * @author Dieter Oberkofler
 * @copyright 2015 Ian VanSchooten. All rights reserved.
 * @copyright 2015 Dieter Oberkofler. All rights reserved.
 */

"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Determine if a node has a possiblity to be an Error object
 * @param  {ASTNode}  node  ASTNode to check
 * @returns {boolean}       True if there is a chance it contains an Error obj
 */
function couldBeError(_x) {
    var _left;

    var _again = true;

    _function: while (_again) {
        var node = _x;
        _again = false;

        switch (node.type) {
            case "Identifier":
            case "CallExpression":
            case "NewExpression":
            case "MemberExpression":
            case "TaggedTemplateExpression":
            case "YieldExpression":
                return true; // possibly an error object.

            case "AssignmentExpression":
                _x = node.right;
                _again = true;
                continue _function;

            case "SequenceExpression":
                var exprs = node.expressions;

                if (!(_left = exprs.length !== 0)) {
                    return _left;
                }

                _x = exprs[exprs.length - 1];
                _again = true;
                exprs = undefined;
                continue _function;

            case "LogicalExpression":
                if (_left = couldBeError(node.left)) {
                    return _left;
                }

                _x = node.right;
                _again = true;
                exprs = undefined;
                continue _function;

            case "ConditionalExpression":
                if (_left = couldBeError(node.consequent)) {
                    return _left;
                }

                _x = node.alternate;
                _again = true;
                exprs = undefined;
                continue _function;

            default:
                return false;
        }
    }
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = function (context) {

    return {

        "ThrowStatement": function ThrowStatement(node) {
            if (!couldBeError(node.argument)) {
                context.report(node, "Expected an object to be thrown.");
            } else if (node.argument.type === "Identifier") {
                if (node.argument.name === "undefined") {
                    context.report(node, "Do not throw undefined.");
                }
            }
        }

    };
};

module.exports.schema = [];

//# sourceMappingURL=no-throw-literal-compiled.js.map