{"version":3,"sources":["no-native-reassign.js"],"names":[],"mappings":";;;;;AAKA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AAChC,QAAI,UAAU,GAAG,AAAC,MAAM,IAAI,MAAM,CAAC,UAAU,IAAK,EAAE,CAAC;;;;;;;AAOrD,aAAS,iBAAiB,CAAC,KAAK,EAAE;AAC9B,eAAO,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,UAAS,IAAI,EAAE,QAAQ,EAAE;AACnD,gBAAI,QAAQ,CAAC,SAAS,KAAK,KAAK,IAAI,QAAQ,CAAC,IAAI,KAAK,WAAW,EAAE;AAC/D,oBAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;aAC9B;AACD,mBAAO,IAAI,CAAC;SACf,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;KAC3B;;;;;;;;;;AAUD,aAAS,qBAAqB,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,EAAE,UAAU,EAAE;AACnE,YAAI,UAAU,GAAG,SAAS,CAAC,UAAU,CAAC;;AAEtC,YAAI,UAAU,IACV,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,IACzB,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAC1C,SAAS,CAAC,IAAI,KAAK,KAAK,IACxB,SAAS,CAAC,OAAO,EAAE;;;AAGlB,aAAK,KAAK,CAAC,IAAI,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,UAAU,KAAK,UAAU,CAAA,AAAC,EAClE;AACE,mBAAO,CAAC,MAAM,CACV,UAAU,EACV,wCAAwC,EACxC,EAAC,IAAI,EAAE,UAAU,CAAC,IAAI,EAAC,CAAC,CAAC;SAChC;KACJ;;AAED,WAAO;;;;AAIH,iBAAS,EAAE,mBAAW;AAClB,gBAAI,WAAW,GAAG,OAAO,CAAC,QAAQ,EAAE,CAAC;AACrC,gBAAI,QAAQ,GAAG,iBAAiB,CAAC,WAAW,CAAC,CAAC;AAC9C,uBAAW,CAAC,OAAO,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;SAC3E;KACJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,QAAQ;AAChB,gBAAY,EAAE;AACV,oBAAY,EAAE;AACV,kBAAM,EAAE,OAAO;AACf,mBAAO,EAAE,EAAC,MAAM,EAAE,QAAQ,EAAC;AAC3B,yBAAa,EAAE,IAAI;SACtB;KACJ;AACD,0BAAsB,EAAE,KAAK;CAChC,CACJ,CAAC","file":"no-native-reassign-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag when re-assigning native objects\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var config = context.options[0];\n    var exceptions = (config && config.exceptions) || [];\n\n    /**\n     * Gets the names of writeable built-in variables.\n     * @param {escope.Scope} scope - A scope to get.\n     * @returns {object} A map that its key is variable names.\n     */\n    function getBuiltinGlobals(scope) {\n        return scope.variables.reduce(function(retv, variable) {\n            if (variable.writeable === false && variable.name !== \"__proto__\") {\n                retv[variable.name] = true;\n            }\n            return retv;\n        }, Object.create(null));\n    }\n\n    /**\n     * Reports if a given reference's name is same as native object's.\n     * @param {object} builtins - A map that its key is a variable name.\n     * @param {Reference} reference - A reference to check.\n     * @param {int} index - The index of the reference in the references.\n     * @param {Reference[]} references - The array that the reference belongs to.\n     * @returns {void}\n     */\n    function checkThroughReference(builtins, reference, index, references) {\n        var identifier = reference.identifier;\n\n        if (identifier &&\n            builtins[identifier.name] &&\n            exceptions.indexOf(identifier.name) === -1 &&\n            reference.init === false &&\n            reference.isWrite() &&\n            // Destructuring assignments can have multiple default value,\n            // so possibly there are multiple writeable references for the same identifier.\n            (index === 0 || references[index - 1].identifier !== identifier)\n        ) {\n            context.report(\n                identifier,\n                \"{{name}} is a read-only native object.\",\n                {name: identifier.name});\n        }\n    }\n\n    return {\n        // Checks assignments of global variables.\n        // References to implicit global variables are not resolved,\n        // so those are in the `through` of the global scope.\n        \"Program\": function() {\n            var globalScope = context.getScope();\n            var builtins = getBuiltinGlobals(globalScope);\n            globalScope.through.forEach(checkThroughReference.bind(null, builtins));\n        }\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"exceptions\": {\n                \"type\": \"array\",\n                \"items\": {\"type\": \"string\"},\n                \"uniqueItems\": true\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}