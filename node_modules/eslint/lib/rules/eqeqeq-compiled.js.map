{"version":3,"sources":["eqeqeq.js"],"names":[],"mappings":";;;;;;;AAOA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,UAAU,GAAG,OAAO,CAAC,aAAa,EAAE,CAAC;;;;;;;AAOzC,aAAS,QAAQ,CAAC,IAAI,EAAE;AACpB,eAAO,IAAI,CAAC,IAAI,KAAK,iBAAiB,IAAI,IAAI,CAAC,QAAQ,KAAK,QAAQ,CAAC;KACxE;;;;;;;;AAQD,aAAS,cAAc,CAAC,IAAI,EAAE;AAC1B,eAAO,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KACtD;;;;;;;;AAQD,aAAS,sBAAsB,CAAC,IAAI,EAAE;AAClC,eAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,SAAS,IAC5D,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;KAC9D;;;;;;;;AAQD,aAAS,WAAW,CAAC,IAAI,EAAE;AACvB,eAAO,AAAC,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,IAAI,IACzD,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,IAAI,AAAC,CAAC;KACtE;;;;;;;;;AASD,aAAS,mBAAmB,CAAC,IAAI,EAAE;AAC/B,YAAI,OAAO,GAAG,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC/C,eAAO,EAAC,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,EAAC,CAAC;KAC3E;;AAED,WAAO;AACH,0BAAkB,EAAE,0BAAS,IAAI,EAAE;AAC/B,gBAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,EAAE;AAClD,uBAAO;aACV;;AAED,gBAAI,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,OAAO,KAAK,cAAc,CAAC,IAAI,CAAC,IACnD,sBAAsB,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,CAAA,AAAC,EAAE;AACxD,uBAAO;aACV;;AAED,gBAAI,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,YAAY,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;AAC1D,uBAAO;aACV;;AAED,mBAAO,CAAC,MAAM,CAAC;AACX,oBAAI,EAAE,IAAI;AACV,mBAAG,EAAE,mBAAmB,CAAC,IAAI,CAAC;AAC9B,uBAAO,EAAE,8CAA8C;AACvD,oBAAI,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC,QAAQ,EAAE;AAC3B,mBAAG,EAAE,aAAS,KAAK,EAAE;AACjB,2BAAO,KAAK,CAAC,eAAe,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;iBAC1E;aACJ,CAAC,CAAC;SAEN;KACJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,CAAC,OAAO,EAAE,YAAY,CAAC;CAClC,CACJ,CAAC","file":"eqeqeq-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n * @copyright 2013 Nicholas C. Zakas. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var sourceCode = context.getSourceCode();\n\n    /**\n     * Checks if an expression is a typeof expression\n     * @param  {ASTNode} node The node to check\n     * @returns {boolean} if the node is a typeof expression\n     */\n    function isTypeOf(node) {\n        return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    }\n\n    /**\n     * Checks if either operand of a binary expression is a typeof operation\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if one of the operands is typeof\n     * @private\n     */\n    function isTypeOfBinary(node) {\n        return isTypeOf(node.left) || isTypeOf(node.right);\n    }\n\n    /**\n     * Checks if operands are literals of the same type (via typeof)\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if operands are of same type\n     * @private\n     */\n    function areLiteralsAndSameType(node) {\n        return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\n                typeof node.left.value === typeof node.right.value;\n    }\n\n    /**\n     * Checks if one of the operands is a literal null\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} if operands are null\n     * @private\n     */\n    function isNullCheck(node) {\n        return (node.right.type === \"Literal\" && node.right.value === null) ||\n                (node.left.type === \"Literal\" && node.left.value === null);\n    }\n\n    /**\n     * Gets the location (line and column) of the binary expression's operator\n     * @param {ASTNode} node The binary expression node to check\n     * @param {String} operator The operator to find\n     * @returns {Object} { line, column } location of operator\n     * @private\n     */\n    function getOperatorLocation(node) {\n        var opToken = context.getTokenAfter(node.left);\n        return {line: opToken.loc.start.line, column: opToken.loc.start.column};\n    }\n\n    return {\n        \"BinaryExpression\": function(node) {\n            if (node.operator !== \"==\" && node.operator !== \"!=\") {\n                return;\n            }\n\n            if (context.options[0] === \"smart\" && (isTypeOfBinary(node) ||\n                    areLiteralsAndSameType(node) || isNullCheck(node))) {\n                return;\n            }\n\n            if (context.options[0] === \"allow-null\" && isNullCheck(node)) {\n                return;\n            }\n\n            context.report({\n                node: node,\n                loc: getOperatorLocation(node),\n                message: \"Expected '{{op}}=' and instead saw '{{op}}'.\",\n                data: { op: node.operator },\n                fix: function(fixer) {\n                    return fixer.insertTextAfter(sourceCode.getTokenAfter(node.left), \"=\");\n                }\n            });\n\n        }\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"smart\", \"allow-null\"]\n    }\n];\n"]}