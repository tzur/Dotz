{"version":3,"sources":["no-implicit-coercion.js"],"names":[],"mappings":"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","file":"no-implicit-coercion-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;\n\n/**\n * Parses and normalizes an option object.\n * @param {object} options - An option object to parse.\n * @returns {object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    options = options || {};\n    return {\n        boolean: \"boolean\" in options ? Boolean(options.boolean) : true,\n        number: \"number\" in options ? Boolean(options.number) : true,\n        string: \"string\" in options ? Boolean(options.string) : true\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    return (\n        node.operator === \"~\" &&\n        node.argument.type === \"CallExpression\" &&\n        node.argument.callee.type === \"MemberExpression\" &&\n        node.argument.callee.property.type === \"Identifier\" &&\n        INDEX_OF_PATTERN.test(node.argument.callee.property.name)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|undefined} The first non-numeric item in the BinaryExpression tree or undefined\n */\nfunction getNonNumericOperand(node) {\n    var left = node.left, right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (node.left.type === \"Literal\" && node.left.value === \"\") ||\n        (node.right.type === \"Literal\" && node.right.value === \"\")\n    );\n}\n\n/**\n * Gets a node that is the left or right operand of a node, is not the specified literal.\n * @param {ASTNode} node - A BinaryExpression node to get.\n * @param {any} value - A literal value to check.\n * @returns {ASTNode} A node that is the left or right operand of the node, is not the specified literal.\n */\nfunction getOtherOperand(node, value) {\n    if (node.left.type === \"Literal\" && node.left.value === value) {\n        return node.right;\n    }\n    return node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    var options = parseOptions(context.options[0]);\n\n    return {\n        \"UnaryExpression\": function(node) {\n            // !!foo\n            if (options.boolean && isDoubleLogicalNegating(node)) {\n                context.report(\n                    node,\n                    \"use `Boolean({{code}})` instead.\",\n                    {code: context.getSource(node.argument.argument)});\n            }\n\n            // ~foo.indexOf(bar)\n            if (options.boolean && isBinaryNegatingOfIndexOf(node)) {\n                context.report(\n                    node,\n                    \"use `{{code}} !== -1` instead.\",\n                    {code: context.getSource(node.argument)});\n            }\n\n            // +foo\n            if (options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                context.report(\n                    node,\n                    \"use `Number({{code}})` instead.\",\n                    {code: context.getSource(node.argument)});\n            }\n        },\n\n        // Use `:exit` to prevent double reporting\n        \"BinaryExpression:exit\": function(node) {\n            // 1 * foo\n            var nonNumericOperand = options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n            if (nonNumericOperand) {\n                context.report(\n                    node,\n                    \"use `Number({{code}})` instead.\",\n                    {code: context.getSource(nonNumericOperand)});\n            }\n\n            // \"\" + foo\n            if (options.string && isConcatWithEmptyString(node)) {\n                context.report(\n                    node,\n                    \"use `String({{code}})` instead.\",\n                    {code: context.getSource(getOtherOperand(node, \"\"))});\n            }\n        }\n    };\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"boolean\": {\n                \"type\": \"boolean\"\n            },\n            \"number\": {\n                \"type\": \"boolean\"\n            },\n            \"string\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}