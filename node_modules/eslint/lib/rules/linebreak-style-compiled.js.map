{"version":3,"sources":["linebreak-style.js"],"names":[],"mappings":";;;;;;;;AAQA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;AAC/B,QAAI,eAAe,GAAG,kDAAkD;QACpE,iBAAiB,GAAG,kDAAkD,CAAC;;AAE3E,WAAO;AACH,iBAAS,EAAE,SAAS,sBAAsB,CAAC,IAAI,EAAE;AAC7C,gBAAI,cAAc,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,MAAM;gBAC7C,UAAU,GAAG,cAAc,KAAK,MAAM;gBACtC,UAAU,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC,KAAK,CAAC,2BAA2B,CAAC;gBACnE,WAAW,GAAG,CAAC,CAAC,CAAC;;AAErB,gBAAI,UAAU,KAAK,IAAI,EAAE;AACrB,2BAAW,GAAG,UAAU,CAAC,OAAO,CAAC,UAAU,GAAG,MAAM,GAAG,IAAI,CAAC,CAAC;aAChE;;AAED,gBAAI,WAAW,KAAK,CAAC,CAAC,EAAE;AACpB,uBAAO,CAAC,MAAM,CAAC,IAAI,EAAE;AACjB,wBAAI,EAAE,WAAW,GAAG,CAAC;AACrB,0BAAM,EAAE,OAAO,CAAC,cAAc,EAAE,CAAC,WAAW,CAAC,CAAC,MAAM;iBACvD,EAAE,UAAU,GAAG,eAAe,GAAG,iBAAiB,CAAC,CAAC;aACxD;SACJ;KACJ,CAAC;CACL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,CAAC,MAAM,EAAE,SAAS,CAAC;CAC9B,CACJ,CAAC","file":"linebreak-style-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to forbid mixing LF and LFCR line breaks.\n * @author Erik Mueller\n * @copyright 2015 Varun Verma. All rights reserverd.\n * @copyright 2015 James Whitney. All rights reserved.\n * @copyright 2015 Erik Mueller. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    var EXPECTED_LF_MSG = \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n        EXPECTED_CRLF_MSG = \"Expected linebreaks to be 'CRLF' but found 'LF'.\";\n\n    return {\n        \"Program\": function checkForlinebreakStyle(node) {\n            var linebreakStyle = context.options[0] || \"unix\",\n                expectedLF = linebreakStyle === \"unix\",\n                linebreaks = context.getSource().match(/\\r\\n|\\r|\\n|\\u2028|\\u2029/g),\n                lineOfError = -1;\n\n            if (linebreaks !== null) {\n                lineOfError = linebreaks.indexOf(expectedLF ? \"\\r\\n\" : \"\\n\");\n            }\n\n            if (lineOfError !== -1) {\n                context.report(node, {\n                    line: lineOfError + 1,\n                    column: context.getSourceLines()[lineOfError].length\n                }, expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG);\n            }\n        }\n    };\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"unix\", \"windows\"]\n    }\n];\n"]}