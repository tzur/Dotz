{"version":3,"sources":["valid-typeof.js"],"names":[],"mappings":";;;;AAIA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,WAAW,GAAG,CAAC,QAAQ,EAAE,WAAW,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE,UAAU,CAAC;QAC1F,SAAS,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;;;;;;AAM3C,WAAO;;AAEH,yBAAiB,EAAE,yBAAS,IAAI,EAAE;AAC9B,gBAAI,MAAM,EAAE,OAAO,CAAC;;AAEpB,gBAAI,IAAI,CAAC,QAAQ,KAAK,QAAQ,EAAE;AAC5B,sBAAM,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC,GAAG,EAAE,CAAC;;AAEtC,oBAAI,MAAM,CAAC,IAAI,KAAK,kBAAkB,IAAI,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;AACjF,2BAAO,GAAG,MAAM,CAAC,IAAI,KAAK,IAAI,GAAG,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC;;AAE5D,wBAAI,OAAO,CAAC,IAAI,KAAK,SAAS,IAAI,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;AACzE,+BAAO,CAAC,MAAM,CAAC,OAAO,EAAE,iCAAiC,CAAC,CAAC;qBAC9D;iBACJ;aACJ;SACJ;;KAEJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"valid-typeof-compiled.js","sourcesContent":["/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\"],\n        OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n\n        \"UnaryExpression\": function(node) {\n            var parent, sibling;\n\n            if (node.operator === \"typeof\") {\n                parent = context.getAncestors().pop();\n\n                if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n                    sibling = parent.left === node ? parent.right : parent.left;\n\n                    if (sibling.type === \"Literal\" && VALID_TYPES.indexOf(sibling.value) === -1) {\n                        context.report(sibling, \"Invalid typeof comparison value\");\n                    }\n                }\n            }\n        }\n\n    };\n\n};\n\nmodule.exports.schema = [];\n"]}