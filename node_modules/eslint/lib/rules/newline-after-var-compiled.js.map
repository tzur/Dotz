{"version":3,"sources":["newline-after-var.js"],"names":[],"mappings":"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","file":"newline-after-var-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n * @copyright 2015 Gopal Venkatesan. All rights reserved.\n * @copyright 2015 Casey Visco. All rights reserved.\n * @copyright 2015 Ian VanSchooten. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var ALWAYS_MESSAGE = \"Expected blank line after variable declarations.\",\n        NEVER_MESSAGE = \"Unexpected blank line after variable declarations.\";\n\n    // Default `mode` to \"always\". This means that invalid options will also\n    // be treated as \"always\" and the only special case is \"never\"\n    var mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n\n    // Cache starting and ending line numbers of comments for faster lookup\n    var commentEndLine = context.getAllComments().reduce(function(result, token) {\n        result[token.loc.start.line] = token.loc.end.line;\n        return result;\n    }, {});\n\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Determine if provided keyword is a variable declaration\n     * @private\n     * @param {string} keyword - keyword to test\n     * @returns {boolean} True if `keyword` is a type of var\n     */\n    function isVar(keyword) {\n        return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n    }\n\n    /**\n     * Determine if provided keyword is a variant of for specifiers\n     * @private\n     * @param {string} keyword - keyword to test\n     * @returns {boolean} True if `keyword` is a variant of for specifier\n     */\n    function isForTypeSpecifier(keyword) {\n        return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n    }\n\n    /**\n     * Determine if provided keyword is an export specifiers\n     * @private\n     * @param {string} nodeType - nodeType to test\n     * @returns {boolean} True if `nodeType` is an export specifier\n     */\n    function isExportSpecifier(nodeType) {\n        return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" ||\n            nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n    }\n\n    /**\n     * Determine if provided nodeType is a function specifier\n     * @private\n     * @param {string} nodeType - nodeType to test\n     * @returns {boolean} True if `nodeType` is a function specifier\n     */\n    function isFunctionSpecifier(nodeType) {\n        return nodeType === \"FunctionDeclaration\" || nodeType === \"FunctionExpression\" ||\n            nodeType === \"ArrowFunctionExpression\";\n    }\n\n    /**\n     * Determine if provided node is the last of his parent\n     * @private\n     * @param {ASTNode} node - node to test\n     * @returns {boolean} True if `node` is last of his parent\n     */\n    function isLastNode(node) {\n        return node.parent.body[node.parent.body.length - 1] === node;\n    }\n\n    /**\n     * Determine if a token starts more than one line after a comment ends\n     * @param  {token}   token            The token being checked\n     * @param {integer}  commentStartLine The line number on which the comment starts\n     * @returns {boolean}                 True if `token` does not start immediately after a comment\n     */\n    function hasBlankLineAfterComment(token, commentStartLine) {\n        var commentEnd = commentEndLine[commentStartLine];\n        // If there's another comment, repeat check for blank line\n        if (commentEndLine[commentEnd + 1]) {\n            return hasBlankLineAfterComment(token, commentEnd + 1);\n        }\n        return (token.loc.start.line > commentEndLine[commentStartLine] + 1);\n    }\n\n    /**\n     * Checks that a blank line exists after a variable declaration when mode is\n     * set to \"always\", or checks that there is no blank line when mode is set\n     * to \"never\"\n     * @private\n     * @param {ASTNode} node - `VariableDeclaration` node to test\n     * @returns {void}\n     */\n    function checkForBlankLine(node) {\n        var lastToken = context.getLastToken(node),\n            nextToken = context.getTokenAfter(node),\n            nextLineNum = lastToken.loc.end.line + 1,\n            noNextLineToken,\n            hasNextLineComment;\n\n        // Ignore if there is no following statement\n        if (!nextToken) {\n            return;\n        }\n\n        // Ignore if parent of node is a for variant\n        if (isForTypeSpecifier(node.parent.type)) {\n            return;\n        }\n\n        // Ignore if parent of node is an export specifier\n        if (isExportSpecifier(node.parent.type)) {\n            return;\n        }\n\n        // Some coding styles use multiple `var` statements, so do nothing if\n        // the next token is a `var` statement.\n        if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n            return;\n        }\n\n        // Ignore if it is last statement in a function\n        if (node.parent.parent && isFunctionSpecifier(node.parent.parent.type) && isLastNode(node)) {\n            return;\n        }\n\n        // Next statement is not a `var`...\n        noNextLineToken = nextToken.loc.start.line > nextLineNum;\n        hasNextLineComment = (typeof commentEndLine[nextLineNum] !== \"undefined\");\n\n        if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n            context.report(node, NEVER_MESSAGE, { identifier: node.name });\n        }\n\n        // Token on the next line, or comment without blank line\n        if (\n            mode === \"always\" && (\n                !noNextLineToken ||\n                hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)\n            )\n        ) {\n            context.report(node, ALWAYS_MESSAGE, { identifier: node.name });\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        \"VariableDeclaration\": checkForBlankLine\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"never\", \"always\"]\n    }\n];\n"]}