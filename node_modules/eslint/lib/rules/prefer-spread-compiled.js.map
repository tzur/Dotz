{"version":3,"sources":["prefer-spread.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;AAEb,IAAI,QAAQ,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;;;;;;;;;;;AAWvC,SAAS,sBAAsB,CAAC,IAAI,EAAE;AAClC,WACI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,kBAAkB,IACvC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,KAAK,YAAY,IAC1C,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,KAAK,OAAO,IACrC,IAAI,CAAC,MAAM,CAAC,QAAQ,KAAK,KAAK,IAC9B,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,IAC3B,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,iBAAiB,CAC9C;CACL;;;;;;;;;AASD,SAAS,WAAW,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE;AACvC,QAAI,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;AACtC,QAAI,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;;AAEvC,QAAI,OAAO,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,EAAE;AACnC,eAAO,KAAK,CAAC;KAChB;AACD,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;AACrC,YAAI,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,IACnC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,EACvC;AACE,mBAAO,KAAK,CAAC;SAChB;KACJ;;AAED,WAAO,IAAI,CAAC;CACf;;;;;;;;;AASD,SAAS,cAAc,CAAC,YAAY,EAAE,OAAO,EAAE,OAAO,EAAE;AACpD,QAAI,CAAC,YAAY,EAAE;AACf,eAAO,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;KAC9C;AACD,WAAO,WAAW,CAAC,YAAY,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;CACtD;;;;;;AAMD,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;AAC/B,WAAO;AACH,wBAAgB,EAAE,wBAAS,IAAI,EAAE;AAC7B,gBAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,EAAE;AAC/B,uBAAO;aACV;;AAED,gBAAI,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;AACjC,gBAAI,YAAY,GAAG,AAAC,OAAO,CAAC,IAAI,KAAK,kBAAkB,GAAI,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;AACjF,gBAAI,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;;AAEhC,gBAAI,cAAc,CAAC,YAAY,EAAE,OAAO,EAAE,OAAO,CAAC,EAAE;AAChD,uBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,sDAAsD,CAAC,CAAC;aAChF;SACJ;KACJ,CAAC;CACL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"prefer-spread-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n */\n\n\"use strict\";\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.apply()` for variadic.\n * @param {ASTNode} node - A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.apply()` for variadic.\n */\nfunction isVariadicApplyCalling(node) {\n    return (\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.property.name === \"apply\" &&\n        node.callee.computed === false &&\n        node.arguments.length === 2 &&\n        node.arguments[1].type !== \"ArrayExpression\"\n    );\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left - A node 1 to compare.\n * @param {ASTNode} right - A node 2 to compare.\n * @param {RuleContext} context - The ESLint rule context object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, context) {\n    var tokensL = context.getTokens(left);\n    var tokensR = context.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (var i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.apply()`.\n * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.\n * @param {ASTNode} thisArg - The node that is given to the first argument of the `.apply()`.\n * @param {RuleContext} context - The ESLint rule context object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, context) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return equalTokens(expectedThis, thisArg, context);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    return {\n        \"CallExpression\": function(node) {\n            if (!isVariadicApplyCalling(node)) {\n                return;\n            }\n\n            var applied = node.callee.object;\n            var expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n            var thisArg = node.arguments[0];\n\n            if (isValidThisArg(expectedThis, thisArg, context)) {\n                context.report(node, \"use the spread operator instead of the \\\".apply()\\\".\");\n            }\n        }\n    };\n};\n\nmodule.exports.schema = [];\n"]}