{"version":3,"sources":["no-undef.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;;;;;;;;;;;;;;;;;AAkBb,SAAS,gBAAgB,CAAC,QAAQ,EAAE;AAChC,WAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,UAAS,GAAG,EAAE;AACrC,eAAO,GAAG,CAAC,IAAI,KAAK,wBAAwB,CAAC;KAChD,CAAC,CAAC;CACN;;;;;;;;AAQD,SAAS,yBAAyB,CAAC,KAAK,EAAE,GAAG,EAAE;AAC3C,QAAI,cAAc,GAAG,IAAI,CAAC;AAC1B,SAAK,CAAC,SAAS,CAAC,IAAI,CAAC,UAAS,QAAQ,EAAE;AACpC,YAAI,QAAQ,CAAC,IAAI,KAAK,GAAG,CAAC,UAAU,CAAC,IAAI,EAAE;;AAEvC,gBAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAA,GAAE,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,EAAE;AAC9E,8BAAc,GAAG,QAAQ,CAAC;AAC1B,uBAAO,IAAI,CAAC;aACf;SACJ;AACD,eAAO,KAAK,CAAC;KAChB,CAAC,CAAC;AACH,WAAO,cAAc,CAAC;CACzB;;;;;;;AAOD,SAAS,iBAAiB,CAAC,IAAI,EAAE;AAC7B,QAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;AACzB,WAAO,MAAM,CAAC,IAAI,KAAK,iBAAiB,IAAI,MAAM,CAAC,QAAQ,KAAK,QAAQ,CAAC;CAC5E;;;;;;AAMD,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,mBAAmB,GAAG,8BAA8B;QACpD,iBAAiB,GAAG,4BAA4B,CAAC;;AAErD,QAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACjC,QAAI,cAAc,GAAG,OAAO,IAAI,OAAO,UAAO,KAAK,IAAI,IAAI,KAAK,CAAC;;AAEjE,WAAO;;AAEH,sBAAc,EAAE,iCAAqB;;AAEjC,gBAAI,WAAW,GAAG,OAAO,CAAC,QAAQ,EAAE,CAAC;;AAErC,uBAAW,CAAC,OAAO,CAAC,OAAO,CAAC,UAAS,GAAG,EAAE;AACtC,oBAAI,QAAQ,GAAG,yBAAyB,CAAC,WAAW,EAAE,GAAG,CAAC;oBACtD,IAAI,GAAG,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC;;AAE/B,oBAAI,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,EAAE;AACtD,2BAAO;iBACV;;AAED,oBAAI,CAAC,QAAQ,EAAE;AACX,2BAAO,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,mBAAmB,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;iBACvE,MAAM,IAAI,GAAG,CAAC,OAAO,EAAE,IAAI,QAAQ,CAAC,SAAS,KAAK,KAAK,EAAE;AACtD,2BAAO,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,iBAAiB,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;iBACrE;aACJ,CAAC,CAAC;SAEN;;KAEJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,QAAQ;AAChB,gBAAY,EAAE;AACV,gBAAQ,EAAE;AACN,kBAAM,EAAE,SAAS;SACpB;KACJ;AACD,0BAAsB,EAAE,KAAK;CAChC,CACJ,CAAC","file":"no-undef-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag references to undeclared variables.\n * @author Mark Macdonald\n * @copyright 2015 Nicholas C. Zakas. All rights reserved.\n * @copyright 2013 Mark Macdonald. All rights reserved.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check if a variable is an implicit declaration\n * @param {ASTNode} variable node to evaluate\n * @returns {boolean} True if its an implicit declaration\n * @private\n */\nfunction isImplicitGlobal(variable) {\n    return variable.defs.every(function(def) {\n        return def.type === \"ImplicitGlobalVariable\";\n    });\n}\n\n/**\n * Gets the declared variable, defined in `scope`, that `ref` refers to.\n * @param {Scope} scope The scope in which to search.\n * @param {Reference} ref The reference to find in the scope.\n * @returns {Variable} The variable, or null if ref refers to an undeclared variable.\n */\nfunction getDeclaredGlobalVariable(scope, ref) {\n    var declaredGlobal = null;\n    scope.variables.some(function(variable) {\n        if (variable.name === ref.identifier.name) {\n            // If it's an implicit global, it must have a `writeable` field (indicating it was declared)\n            if (!isImplicitGlobal(variable) || {}.hasOwnProperty.call(variable, \"writeable\")) {\n                declaredGlobal = variable;\n                return true;\n            }\n        }\n        return false;\n    });\n    return declaredGlobal;\n}\n\n/**\n * Checks if the given node is the argument of a typeof operator.\n * @param {ASTNode} node The AST node being checked.\n * @returns {boolean} Whether or not the node is the argument of a typeof operator.\n */\nfunction hasTypeOfOperator(node) {\n    var parent = node.parent;\n    return parent.type === \"UnaryExpression\" && parent.operator === \"typeof\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var NOT_DEFINED_MESSAGE = \"\\\"{{name}}\\\" is not defined.\",\n        READ_ONLY_MESSAGE = \"\\\"{{name}}\\\" is read only.\";\n\n    var options = context.options[0];\n    var considerTypeOf = options && options.typeof === true || false;\n\n    return {\n\n        \"Program:exit\": function(/* node */) {\n\n            var globalScope = context.getScope();\n\n            globalScope.through.forEach(function(ref) {\n                var variable = getDeclaredGlobalVariable(globalScope, ref),\n                    name = ref.identifier.name;\n\n                if (hasTypeOfOperator(ref.identifier) && !considerTypeOf) {\n                    return;\n                }\n\n                if (!variable) {\n                    context.report(ref.identifier, NOT_DEFINED_MESSAGE, { name: name });\n                } else if (ref.isWrite() && variable.writeable === false) {\n                    context.report(ref.identifier, READ_ONLY_MESSAGE, { name: name });\n                }\n            });\n\n        }\n\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"typeof\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}