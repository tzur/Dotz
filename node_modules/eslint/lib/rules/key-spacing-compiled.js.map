{"version":3,"sources":["key-spacing.js"],"names":[],"mappings":"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","file":"key-spacing-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n * @copyright 2014 Brandon Mills. All rights reserved.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return /[\\n\\r\\u2028\\u2029]/.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a property is a member of the property group it follows.\n * @param {ASTNode} lastMember The last Property known to be in the group.\n * @param {ASTNode} candidate The next Property that might be in the group.\n * @returns {boolean} True if the candidate property is part of the group.\n */\nfunction continuesPropertyGroup(lastMember, candidate) {\n    var groupEndLine = lastMember.loc.start.line,\n        candidateStartLine = candidate.loc.start.line,\n        comments, i;\n\n    if (candidateStartLine - groupEndLine <= 1) {\n        return true;\n    }\n\n    // Check that the first comment is adjacent to the end of the group, the\n    // last comment is adjacent to the candidate property, and that successive\n    // comments are adjacent to each other.\n    comments = candidate.leadingComments;\n    if (\n        comments &&\n        comments[0].loc.start.line - groupEndLine <= 1 &&\n        candidateStartLine - last(comments).loc.end.line <= 1\n    ) {\n        for (i = 1; i < comments.length; i++) {\n            if (comments[i].loc.start.line - comments[i - 1].loc.end.line > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nvar messages = {\n    key: \"{{error}} space after {{computed}}key \\\"{{key}}\\\".\",\n    value: \"{{error}} space before value for {{computed}}key \\\"{{key}}\\\".\"\n};\n\nmodule.exports = function(context) {\n\n    /**\n     * OPTIONS\n     * \"key-spacing\": [2, {\n     *     beforeColon: false,\n     *     afterColon: true,\n     *     align: \"colon\" // Optional, or \"value\"\n     * }\n     */\n\n    var options = context.options[0] || {},\n        align = options.align,\n        mode = options.mode || \"strict\",\n        beforeColon = +!!options.beforeColon, // Defaults to false\n        afterColon = +!(options.afterColon === false); // Defaults to true\n\n    /**\n     * Starting from the given a node (a property.key node here) looks forward\n     * until it finds the last token before a colon punctuator and returns it.\n     * @param {ASTNode} node The node to start looking from.\n     * @returns {ASTNode} The last token before a colon punctuator.\n     */\n    function getLastTokenBeforeColon(node) {\n        var prevNode;\n\n        while (node && (node.type !== \"Punctuator\" || node.value !== \":\")) {\n            prevNode = node;\n            node = context.getTokenAfter(node);\n        }\n\n        return prevNode;\n    }\n\n    /**\n     * Gets an object literal property's key as the identifier name or string value.\n     * @param {ASTNode} property Property node whose key to retrieve.\n     * @returns {string} The property's key.\n     */\n    function getKey(property) {\n        var key = property.key;\n\n        if (property.computed) {\n            return context.getSource().slice(key.range[0], key.range[1]);\n        }\n\n        return property.key.name || property.key.value;\n    }\n\n    /**\n     * Reports an appropriately-formatted error if spacing is incorrect on one\n     * side of the colon.\n     * @param {ASTNode} property Key-value pair in an object literal.\n     * @param {string} side Side being verified - either \"key\" or \"value\".\n     * @param {string} whitespace Actual whitespace string.\n     * @param {int} expected Expected whitespace length.\n     * @returns {void}\n     */\n    function report(property, side, whitespace, expected) {\n        var diff = whitespace.length - expected,\n            key = property.key,\n            firstTokenAfterColon = context.getTokenAfter(key, 1),\n            location = side === \"key\" ? key.loc.start : firstTokenAfterColon.loc.start;\n\n        if ((diff && mode === \"strict\" || diff < 0 && mode === \"minimum\") &&\n            !(expected && containsLineTerminator(whitespace))\n        ) {\n            context.report(property[side], location, messages[side], {\n                error: diff > 0 ? \"Extra\" : \"Missing\",\n                computed: property.computed ? \"computed \" : \"\",\n                key: getKey(property)\n            });\n        }\n    }\n\n    /**\n     * Gets the number of characters in a key, including quotes around string\n     * keys and braces around computed property keys.\n     * @param {ASTNode} property Property of on object literal.\n     * @returns {int} Width of the key.\n     */\n    function getKeyWidth(property) {\n        var startToken, endToken;\n\n        // Ignore shorthand methods and properties, as they have no colon\n        if (property.method || property.shorthand) {\n            return 0;\n        }\n\n        startToken = context.getFirstToken(property);\n        endToken = getLastTokenBeforeColon(property.key);\n\n        return endToken.range[1] - startToken.range[0];\n    }\n\n    /**\n     * Gets the whitespace around the colon in an object literal property.\n     * @param {ASTNode} property Property node from an object literal.\n     * @returns {Object} Whitespace before and after the property's colon.\n     */\n    function getPropertyWhitespace(property) {\n        var whitespace = /(\\s*):(\\s*)/.exec(context.getSource().slice(\n            property.key.range[1], property.value.range[0]\n        ));\n\n        if (whitespace) {\n            return {\n                beforeColon: whitespace[1],\n                afterColon: whitespace[2]\n            };\n        }\n    }\n\n    /**\n     * Creates groups of properties.\n     * @param  {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n     */\n    function createGroups(node) {\n        if (node.properties.length === 1) {\n            return [node.properties];\n        }\n\n        return node.properties.reduce(function(groups, property) {\n            var currentGroup = last(groups),\n                prev = last(currentGroup);\n\n            if (!prev || continuesPropertyGroup(prev, property)) {\n                currentGroup.push(property);\n            } else {\n                groups.push([property]);\n            }\n\n            return groups;\n        }, [[]]);\n    }\n\n    /**\n     * Verifies correct vertical alignment of a group of properties.\n     * @param {ASTNode[]} properties List of Property AST nodes.\n     * @returns {void}\n     */\n    function verifyGroupAlignment(properties) {\n        var length = properties.length,\n            widths = properties.map(getKeyWidth), // Width of keys, including quotes\n            targetWidth = Math.max.apply(null, widths),\n            i, property, whitespace, width;\n\n        // Conditionally include one space before or after colon\n        targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n        for (i = 0; i < length; i++) {\n            property = properties[i];\n            whitespace = getPropertyWhitespace(property);\n\n            if (!whitespace) {\n                continue; // Object literal getters/setters lack a colon\n            }\n\n            width = widths[i];\n\n            if (align === \"value\") {\n                report(property, \"key\", whitespace.beforeColon, beforeColon);\n                report(property, \"value\", whitespace.afterColon, targetWidth - width);\n            } else { // align = \"colon\"\n                report(property, \"key\", whitespace.beforeColon, targetWidth - width);\n                report(property, \"value\", whitespace.afterColon, afterColon);\n            }\n        }\n    }\n\n    /**\n     * Verifies vertical alignment, taking into account groups of properties.\n     * @param  {ASTNode} node ObjectExpression node being evaluated.\n     * @returns {void}\n     */\n    function verifyAlignment(node) {\n        createGroups(node).forEach(function(group) {\n            verifyGroupAlignment(group);\n        });\n    }\n\n    /**\n     * Verifies spacing of property conforms to specified options.\n     * @param  {ASTNode} node Property node being evaluated.\n     * @returns {void}\n     */\n    function verifySpacing(node) {\n        var whitespace = getPropertyWhitespace(node);\n        if (whitespace) { // Object literal getters/setters lack colons\n            report(node, \"key\", whitespace.beforeColon, beforeColon);\n            report(node, \"value\", whitespace.afterColon, afterColon);\n        }\n    }\n\n    /**\n     * Verifies spacing of each property in a list.\n     * @param  {ASTNode[]} properties List of Property AST nodes.\n     * @returns {void}\n     */\n    function verifyListSpacing(properties) {\n        var length = properties.length;\n\n        for (var i = 0; i < length; i++) {\n            verifySpacing(properties[i]);\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    if (align) { // Verify vertical alignment\n\n        return {\n            \"ObjectExpression\": function(node) {\n                if (isSingleLine(node)) {\n                    verifyListSpacing(node.properties);\n                } else {\n                    verifyAlignment(node);\n                }\n            }\n        };\n\n    } else { // Strictly obey beforeColon and afterColon in each property\n\n        return {\n            \"Property\": function(node) {\n                verifySpacing(node);\n            }\n        };\n\n    }\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"align\": {\n                \"enum\": [\"colon\", \"value\"]\n            },\n            \"mode\": {\n                \"enum\": [\"strict\", \"minimum\"]\n            },\n            \"beforeColon\": {\n                \"type\": \"boolean\"\n            },\n            \"afterColon\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}