{"version":3,"sources":["no-func-assign.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;AAEb,IAAI,QAAQ,GAAG,OAAO,CAAC,cAAc,CAAC,CAAC;;;;;;AAMvC,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;;;;;;;AAOrC,aAAS,2BAA2B,GAAG;AACnC,kBAAU,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;;AAEjC,YAAI,UAAU,GAAG,OAAO,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC;AAC5C,aAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;AACxC,gBAAI,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;AAC9B,gBAAI,IAAI,GAAG,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC;;AAErC,gBAAI,IAAI,IAAI,UAAU,KAAK,KAAK,EAAE;AAC9B,0BAAU,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;aACzB;AACD,sBAAU,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;SACpC;KACJ;;;;;;;AAOD,aAAS,cAAc,CAAC,UAAU,EAAE;AAChC,gBAAQ,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAS,SAAS,EAAE;AACpE,mBAAO,CAAC,MAAM,CACV,SAAS,CAAC,UAAU,EACpB,2BAA2B,EAC3B,EAAC,IAAI,EAAE,SAAS,CAAC,UAAU,CAAC,IAAI,EAAC,CAAC,CAAC;SAC1C,CAAC,CAAC;KACN;;;;;;;AAOD,aAAS,aAAa,CAAC,QAAQ,EAAE;AAC7B,YAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,cAAc,EAAE;;;AAG1C,gBAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;AAChC,8BAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;aACvC,MAAM,IAAI,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AAClC,8BAAc,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;aAC7C;SACJ;KACJ;;;;;;;AAOD,aAAS,gBAAgB,CAAC,IAAI,EAAE;AAC5B,eAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;KAC7D;;AAED,WAAO;AACH,iBAAS,EAAE,2BAA2B;AACtC,6BAAqB,EAAE,gBAAgB;AACvC,4BAAoB,EAAE,gBAAgB;KACzC,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"no-func-assign-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag use of function declaration identifiers as variables.\n * @author Ian Christian Myers\n * @copyright 2013 Ian Christian Myers. All rights reserved.\n */\n\n\"use strict\";\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var unresolved = Object.create(null);\n\n    /**\n     * Collects unresolved references from the global scope, then creates a map to references from its name.\n     * Usage of the map is explained at `checkVariable(variable)`.\n     * @returns {void}\n     */\n    function collectUnresolvedReferences() {\n        unresolved = Object.create(null);\n\n        var references = context.getScope().through;\n        for (var i = 0; i < references.length; ++i) {\n            var reference = references[i];\n            var name = reference.identifier.name;\n\n            if (name in unresolved === false) {\n                unresolved[name] = [];\n            }\n            unresolved[name].push(reference);\n        }\n    }\n\n    /**\n     * Reports a reference if is non initializer and writable.\n     * @param {References} references - Collection of reference to check.\n     * @returns {void}\n     */\n    function checkReference(references) {\n        astUtils.getModifyingReferences(references).forEach(function(reference) {\n            context.report(\n                reference.identifier,\n                \"'{{name}}' is a function.\",\n                {name: reference.identifier.name});\n        });\n    }\n\n    /**\n     * Finds and reports references that are non initializer and writable.\n     * @param {Variable} variable - A variable to check.\n     * @returns {void}\n     */\n    function checkVariable(variable) {\n        if (variable.defs[0].type === \"FunctionName\") {\n            // If the function is in global scope, its references are not resolved (by escope's design).\n            // So when references of the function are nothing, this checks in unresolved.\n            if (variable.references.length > 0) {\n                checkReference(variable.references);\n            } else if (unresolved[variable.name]) {\n                checkReference(unresolved[variable.name]);\n            }\n        }\n    }\n\n    /**\n     * Checks parameters of a given function node.\n     * @param {ASTNode} node - A function node to check.\n     * @returns {void}\n     */\n    function checkForFunction(node) {\n        context.getDeclaredVariables(node).forEach(checkVariable);\n    }\n\n    return {\n        \"Program\": collectUnresolvedReferences,\n        \"FunctionDeclaration\": checkForFunction,\n        \"FunctionExpression\": checkForFunction\n    };\n\n};\n\nmodule.exports.schema = [];\n"]}