{"version":3,"sources":["no-inner-declarations.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;;;;;AAM/B,aAAS,WAAW,GAAG;AACnB,YAAI,SAAS,GAAG,OAAO,CAAC,YAAY,EAAE;YAClC,QAAQ,GAAG,SAAS,CAAC,GAAG,EAAE;YAC1B,UAAU,GAAG,CAAC,CAAC;;AAEnB,eAAO,QAAQ,IAAI,CAAC,SAAS,EAAE,qBAAqB,EAC5C,oBAAoB,EAAE,yBAAyB,CAC9C,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;AAClC,sBAAU,IAAI,CAAC,CAAC;AAChB,oBAAQ,GAAG,SAAS,CAAC,GAAG,EAAE,CAAC;SAC9B;;AAED,eAAO;;AAEH,gBAAI,EAAE,QAAQ,CAAC,IAAI;;AAEnB,oBAAQ,EAAE,UAAU;SACvB,CAAC;KACL;;;;;;;AAOD,aAAS,KAAK,CAAC,IAAI,EAAE;AACjB,YAAI,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC;YACxB,KAAK,GAAI,AAAC,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,IACpD,IAAI,CAAC,QAAQ,KAAK,CAAC,AAAC,CAAC;;AAE7B,YAAI,CAAC,KAAK,EAAE;AACR,mBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,6CAA6C,EAC9D;AACI,oBAAI,EAAG,IAAI,CAAC,IAAI,KAAK,qBAAqB,GACtC,UAAU,GAAG,UAAU,AAAC;AAC5B,oBAAI,EAAG,IAAI,CAAC,IAAI,KAAK,SAAS,GAC1B,SAAS,GAAG,eAAe,AAAC;aACnC,CACJ,CAAC;SACL;KACJ;;AAED,WAAO;;AAEH,6BAAqB,EAAE,KAAK;AAC5B,6BAAqB,EAAE,6BAAS,IAAI,EAAE;AAClC,gBAAI,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;AACtD,qBAAK,CAAC,IAAI,CAAC,CAAC;aACf;SACJ;;KAEJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,CAAC,WAAW,EAAE,MAAM,CAAC;CAChC,CACJ,CAAC","file":"no-inner-declarations-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to enforce declarations in program or function body root.\n * @author Brandon Mills\n * @copyright 2014 Brandon Mills. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    /**\n     * Find the nearest Program or Function ancestor node.\n     * @returns {Object} Ancestor's type and distance from node.\n     */\n    function nearestBody() {\n        var ancestors = context.getAncestors(),\n            ancestor = ancestors.pop(),\n            generation = 1;\n\n        while (ancestor && [\"Program\", \"FunctionDeclaration\",\n                \"FunctionExpression\", \"ArrowFunctionExpression\"\n                ].indexOf(ancestor.type) < 0) {\n            generation += 1;\n            ancestor = ancestors.pop();\n        }\n\n        return {\n            // Type of containing ancestor\n            type: ancestor.type,\n            // Separation between ancestor and node\n            distance: generation\n        };\n    }\n\n    /**\n     * Ensure that a given node is at a program or function body's root.\n     * @param {ASTNode} node Declaration node to check.\n     * @returns {void}\n     */\n    function check(node) {\n        var body = nearestBody(node),\n            valid = ((body.type === \"Program\" && body.distance === 1) ||\n                body.distance === 2);\n\n        if (!valid) {\n            context.report(node, \"Move {{type}} declaration to {{body}} root.\",\n                {\n                    type: (node.type === \"FunctionDeclaration\" ?\n                        \"function\" : \"variable\"),\n                    body: (body.type === \"Program\" ?\n                        \"program\" : \"function body\")\n                }\n            );\n        }\n    }\n\n    return {\n\n        \"FunctionDeclaration\": check,\n        \"VariableDeclaration\": function(node) {\n            if (context.options[0] === \"both\" && node.kind === \"var\") {\n                check(node);\n            }\n        }\n\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"functions\", \"both\"]\n    }\n];\n"]}