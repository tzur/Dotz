{"version":3,"sources":["yoda.js"],"names":[],"mappings":"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","file":"yoda-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n * @copyright 2014 Nicholas C. Zakas. All rights reserved.\n * @copyright 2014 Brandon Mills. All rights reserved.\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {String} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {String} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return (/^(==|===)$/).test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {String} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction looksLikeLiteral(node) {\n    return (node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        node.argument.type === \"Literal\" &&\n        typeof node.argument.value === \"number\");\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} The original node if the node is already a Literal, or a\n *                    normalized Literal node with the negative number as the\n *                    value if the node represents a negative number literal,\n *                    otherwise null if the node cannot be converted to a\n *                    normalized literal.\n */\nfunction getNormalizedLiteral(node) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (looksLikeLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: \"-\" + node.argument.value\n        };\n    }\n\n    return null;\n}\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n        case \"Literal\":\n            return a.value === b.value;\n        case \"MemberExpression\":\n            // x[0] = x[0]\n            // x[y] = x[y]\n            // x.y = x.y\n            return same(a.object, b.object) && same(a.property, b.property);\n        case \"ThisExpression\":\n            return true;\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    // Default to \"never\" (!always) if no option\n    var always = (context.options[0] === \"always\");\n    var exceptRange = (context.options[1] && context.options[1].exceptRange);\n    var onlyEquality = (context.options[1] && context.options[1].onlyEquality);\n\n    /**\n     * Determines whether node represents a range test.\n     * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n     * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n     * both operators must be `<` or `<=`. Finally, the literal on the left side\n     * must be less than or equal to the literal on the right side so that the\n     * test makes any sense.\n     * @param {ASTNode} node LogicalExpression node to test.\n     * @returns {Boolean} Whether node is a range test.\n     */\n    function isRangeTest(node) {\n        var left = node.left,\n            right = node.right;\n\n        /**\n         * Determines whether node is of the form `0 <= x && x < 1`.\n         * @returns {Boolean} Whether node is a \"between\" range test.\n         */\n        function isBetweenTest() {\n            var leftLiteral, rightLiteral;\n\n            return (node.operator === \"&&\" &&\n                (leftLiteral = getNormalizedLiteral(left.left)) &&\n                (rightLiteral = getNormalizedLiteral(right.right)) &&\n                leftLiteral.value <= rightLiteral.value &&\n                same(left.right, right.left));\n        }\n\n        /**\n         * Determines whether node is of the form `x < 0 || 1 <= x`.\n         * @returns {Boolean} Whether node is an \"outside\" range test.\n         */\n        function isOutsideTest() {\n            var leftLiteral, rightLiteral;\n\n            return (node.operator === \"||\" &&\n                (leftLiteral = getNormalizedLiteral(left.right)) &&\n                (rightLiteral = getNormalizedLiteral(right.left)) &&\n                leftLiteral.value <= rightLiteral.value &&\n                same(left.left, right.right));\n        }\n\n        /**\n         * Determines whether node is wrapped in parentheses.\n         * @returns {Boolean} Whether node is preceded immediately by an open\n         *                    paren token and followed immediately by a close\n         *                    paren token.\n         */\n        function isParenWrapped() {\n            var tokenBefore, tokenAfter;\n\n            return ((tokenBefore = context.getTokenBefore(node)) &&\n                tokenBefore.value === \"(\" &&\n                (tokenAfter = context.getTokenAfter(node)) &&\n                tokenAfter.value === \")\");\n        }\n\n        return (node.type === \"LogicalExpression\" &&\n            left.type === \"BinaryExpression\" &&\n            right.type === \"BinaryExpression\" &&\n            isRangeTestOperator(left.operator) &&\n            isRangeTestOperator(right.operator) &&\n            (isBetweenTest() || isOutsideTest()) &&\n            isParenWrapped());\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        \"BinaryExpression\": always ? function(node) {\n\n            // Comparisons must always be yoda-style: if (\"blue\" === color)\n            if (\n                (node.right.type === \"Literal\" || looksLikeLiteral(node.right)) &&\n                !(node.left.type === \"Literal\" || looksLikeLiteral(node.left)) &&\n                !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                isComparisonOperator(node.operator) &&\n                !(exceptRange && isRangeTest(context.getAncestors().pop()))\n            ) {\n                context.report(node, \"Expected literal to be on the left side of \" + node.operator + \".\");\n            }\n\n        } : function(node) {\n\n            // Comparisons must never be yoda-style (default)\n            if (\n                (node.left.type === \"Literal\" || looksLikeLiteral(node.left)) &&\n                !(node.right.type === \"Literal\" || looksLikeLiteral(node.right)) &&\n                !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                isComparisonOperator(node.operator) &&\n                !(exceptRange && isRangeTest(context.getAncestors().pop()))\n            ) {\n                context.report(node, \"Expected literal to be on the right side of \" + node.operator + \".\");\n            }\n\n        }\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"always\", \"never\"]\n    },\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"exceptRange\": {\n                \"type\": \"boolean\"\n            },\n            \"onlyEquality\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}