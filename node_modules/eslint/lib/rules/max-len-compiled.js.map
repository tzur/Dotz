{"version":3,"sources":["max-len.js"],"names":[],"mappings":"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","file":"max-len-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n * @copyright 2013 Matt DuVall. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    // takes some ideas from http://tools.ietf.org/html/rfc3986#appendix-B, however:\n    // - They're matching an entire string that we know is a URI\n    // - We're matching part of a string where we think there *might* be a URL\n    // - We're only concerned about URLs, as picking out any URI would cause too many false positives\n    // - We don't care about matching the entire URL, any small segment is fine\n    var URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/;\n\n    /**\n     * Creates a string that is made up of repeating a given string a certain\n     * number of times. This uses exponentiation of squares to achieve significant\n     * performance gains over the more traditional implementation of such\n     * functionality.\n     * @param {string} str The string to repeat.\n     * @param {int} num The number of times to repeat the string.\n     * @returns {string} The created string.\n     * @private\n     */\n    function stringRepeat(str, num) {\n        var result = \"\";\n        for (num |= 0; num > 0; num >>>= 1, str += str) {\n            if (num & 1) {\n                result += str;\n            }\n        }\n        return result;\n    }\n\n    var maxLength = context.options[0] || 80,\n        tabWidth = context.options[1] || 4,\n        ignoreOptions = context.options[2] || {},\n        ignorePattern = ignoreOptions.ignorePattern || null,\n        ignoreComments = ignoreOptions.ignoreComments || false,\n        ignoreUrls = ignoreOptions.ignoreUrls || false,\n        tabString = stringRepeat(\" \", tabWidth);\n\n    if (ignorePattern) {\n        ignorePattern = new RegExp(ignorePattern);\n    }\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Tells if a given comment is trailing: it starts on the current line and\n     * extends to or past the end of the current line.\n     * @param {string} line The source line we want to check for a trailing comment on\n     * @param {number} lineNumber The one-indexed line number for line\n     * @param {ASTNode} comment The comment to inspect\n     * @returns {boolean} If the comment is trailing on the given line\n     */\n    function isTrailingComment(line, lineNumber, comment) {\n        return comment &&\n            (comment.loc.start.line <= lineNumber && lineNumber <= comment.loc.end.line) &&\n            (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n    }\n\n    /**\n     * Gets the line after the comment and any remaining trailing whitespace is\n     * stripped.\n     * @param {string} line The source line with a trailing comment\n     * @param {number} lineNumber The one-indexed line number this is on\n     * @param {ASTNode} comment The comment to remove\n     * @returns {string} Line without comment and trailing whitepace\n     */\n    function stripTrailingComment(line, lineNumber, comment) {\n        if (comment.loc.start.line < lineNumber) {\n            // this entire line is a comment\n            return \"\";\n        } else {\n            // loc.column is zero-indexed\n            return line.slice(0, comment.loc.start.column).replace(/\\s+$/, \"\");\n        }\n    }\n\n    /**\n     * Check the program for max length\n     * @param {ASTNode} node Node to examine\n     * @returns {void}\n     * @private\n     */\n    function checkProgramForMaxLength(node) {\n        // split (honors line-ending)\n        var lines = context.getSourceLines(),\n            // list of comments to ignore\n            comments = ignoreComments ? context.getAllComments() : [],\n            // we iterate over comments in parallel with the lines\n            commentsIndex = 0;\n\n        lines.forEach(function(line, i) {\n            // i is zero-indexed, line numbers are one-indexed\n            var lineNumber = i + 1;\n            // we can short-circuit the comment checks if we're already out of comments to check\n            if (commentsIndex < comments.length) {\n                // iterate over comments until we find one past the current line\n                do {\n                    var comment = comments[++commentsIndex];\n                } while (comment && comment.loc.start.line <= lineNumber);\n                // and step back by one\n                comment = comments[--commentsIndex];\n                if (isTrailingComment(line, lineNumber, comment)) {\n                    line = stripTrailingComment(line, lineNumber, comment);\n                }\n            }\n            if (ignorePattern && ignorePattern.test(line) ||\n                ignoreUrls && URL_REGEXP.test(line)) {\n                // ignore this line\n                return;\n            }\n            // replace the tabs\n            if (line.replace(/\\t/g, tabString).length > maxLength) {\n                context.report(node, { line: lineNumber, column: 0 }, \"Line \" + (i + 1) + \" exceeds the maximum line length of \" + maxLength + \".\");\n            }\n        });\n    }\n\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n        \"Program\": checkProgramForMaxLength\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"integer\",\n        \"minimum\": 0\n    },\n    {\n        \"type\": \"integer\",\n        \"minimum\": 0\n    },\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"ignorePattern\": {\n                \"type\": \"string\"\n            },\n            \"ignoreComments\": {\n                \"type\": \"boolean\"\n            },\n            \"ignoreUrls\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}