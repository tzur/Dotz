{"version":3,"sources":["camelcase.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;;;;;;;;;;;AAY/B,aAAS,aAAa,CAAC,IAAI,EAAE;;;AAGzB,eAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,KAAK,IAAI,CAAC,WAAW,EAAE,CAAC;KAChE;;;;;;;;AAQD,aAAS,MAAM,CAAC,IAAI,EAAE;AAClB,eAAO,CAAC,MAAM,CAAC,IAAI,EAAE,6CAA6C,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;KAC5F;;AAED,QAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE;QAClC,UAAU,GAAG,OAAO,CAAC,UAAU,IAAI,EAAE,CAAC;;AAE1C,QAAI,UAAU,KAAK,QAAQ,IAAI,UAAU,KAAK,OAAO,EAAE;AACnD,kBAAU,GAAG,QAAQ,CAAC;KACzB;;AAED,WAAO;;AAEH,oBAAY,EAAE,oBAAS,IAAI,EAAE;;;AAGzB,gBAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC;gBACxC,eAAe,GAAG,AAAC,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,kBAAkB,GAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;;;AAGnG,gBAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,kBAAkB,EAAE;;;AAGzC,oBAAI,UAAU,KAAK,OAAO,EAAE;AACxB,2BAAO;iBACV;;;AAGD,oBAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,KAAK,YAAY,IACpC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,IACrC,aAAa,CAAC,IAAI,CAAC,EAAE;AACzB,0BAAM,CAAC,IAAI,CAAC,CAAC;;;iBAGhB,MAAM,IAAI,eAAe,CAAC,IAAI,KAAK,sBAAsB,IAClD,aAAa,CAAC,IAAI,CAAC,KAClB,eAAe,CAAC,KAAK,CAAC,IAAI,KAAK,kBAAkB,IAClD,eAAe,CAAC,IAAI,CAAC,IAAI,KAAK,kBAAkB,IAChD,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAA,AAAC,EAAE;AACvD,8BAAM,CAAC,IAAI,CAAC,CAAC;qBAChB;;;aAGJ,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,UAAU,EAAE;;;AAGxC,wBAAI,UAAU,KAAK,OAAO,EAAE;AACxB,+BAAO;qBACV;;AAED,wBAAI,aAAa,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,IAAI,KAAK,gBAAgB,EAAE;AAClE,8BAAM,CAAC,IAAI,CAAC,CAAC;qBAChB;;;iBAGJ,MAAM,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,IAAI,KAAK,gBAAgB,EAAE;AACzE,8BAAM,CAAC,IAAI,CAAC,CAAC;qBAChB;SACJ;;KAEJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,QAAQ;AAChB,gBAAY,EAAE;AACV,oBAAY,EAAE;AACV,kBAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC;SAC9B;KACJ;AACD,0BAAsB,EAAE,KAAK;CAChC,CACJ,CAAC","file":"camelcase-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n * @copyright 2015 Dieter Oberkofler. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks if a string contains an underscore and isn't all upper-case\n     * @param {String} name The string to check.\n     * @returns {boolean} if the string is underscored\n     * @private\n     */\n    function isUnderscored(name) {\n\n        // if there's an underscore, it might be A_CONSTANT, which is okay\n        return name.indexOf(\"_\") > -1 && name !== name.toUpperCase();\n    }\n\n    /**\n     * Reports an AST node as a rule violation.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     * @private\n     */\n    function report(node) {\n        context.report(node, \"Identifier '{{name}}' is not in camel case.\", { name: node.name });\n    }\n\n    var options = context.options[0] || {},\n        properties = options.properties || \"\";\n\n    if (properties !== \"always\" && properties !== \"never\") {\n        properties = \"always\";\n    }\n\n    return {\n\n        \"Identifier\": function(node) {\n\n            // Leading and trailing underscores are commonly used to flag private/protected identifiers, strip them\n            var name = node.name.replace(/^_+|_+$/g, \"\"),\n                effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n            // MemberExpressions get special rules\n            if (node.parent.type === \"MemberExpression\") {\n\n                // \"never\" check properties\n                if (properties === \"never\") {\n                    return;\n                }\n\n                // Always report underscored object names\n                if (node.parent.object.type === \"Identifier\" &&\n                        node.parent.object.name === node.name &&\n                        isUnderscored(name)) {\n                    report(node);\n\n                // Report AssignmentExpressions only if they are the left side of the assignment\n                } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        isUnderscored(name) &&\n                        (effectiveParent.right.type !== \"MemberExpression\" ||\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name)) {\n                    report(node);\n                }\n\n            // Properties have their own rules\n            } else if (node.parent.type === \"Property\") {\n\n                // \"never\" check properties\n                if (properties === \"never\") {\n                    return;\n                }\n\n                if (isUnderscored(name) && effectiveParent.type !== \"CallExpression\") {\n                    report(node);\n                }\n\n            // Report anything that is underscored that isn't a CallExpression\n            } else if (isUnderscored(name) && effectiveParent.type !== \"CallExpression\") {\n                report(node);\n            }\n        }\n\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"properties\": {\n                \"enum\": [\"always\", \"never\"]\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}