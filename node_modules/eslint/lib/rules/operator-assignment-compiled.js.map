{"version":3,"sources":["operator-assignment.js"],"names":[],"mappings":";;;;;AAKA,YAAY,CAAC;;;;;;;;;;;;;AAab,SAAS,kCAAkC,CAAC,QAAQ,EAAE;AAClD,WAAO,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;CACtD;;;;;;;;;AASD,SAAS,qCAAqC,CAAC,QAAQ,EAAE;AACrD,WAAO,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;CACzE;;;;;;;;;;;;;;;;AAgBD,SAAS,IAAI;;;;;8BAAO;YAAN,CAAC;YAAE,CAAC;;;AACd,YAAI,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,EAAE;AACnB,mBAAO,KAAK,CAAC;SAChB;;AAED,gBAAQ,CAAC,CAAC,IAAI;AACV,iBAAK,YAAY;AACb,uBAAO,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,CAAC;AAAA,AAC7B,iBAAK,SAAS;AACV,uBAAO,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,KAAK,CAAC;AAAA,AAC/B,iBAAK,kBAAkB;;;;;8BAIZ,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC;;;;qBAAS,CAAC,CAAC,QAAQ;sBAAE,CAAC,CAAC,QAAQ;;;AAAE;AACpE;AACI,uBAAO,KAAK,CAAC;AAAA,SACpB;KACJ;CAAA;;AAED,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;;;;;;AAO/B,aAAS,MAAM,CAAC,IAAI,EAAE;AAClB,YAAI,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC;;AAEzB,YAAI,IAAI,CAAC,QAAQ,KAAK,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,kBAAkB,EAAE;AACjE,mBAAO;SACV;;AAED,YAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACjB,YAAI,GAAG,IAAI,CAAC,KAAK,CAAC;AAClB,gBAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;;AAEzB,YAAI,kCAAkC,CAAC,QAAQ,CAAC,EAAE;AAC9C,gBAAI,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE;AACjD,uBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,sDAAsD,CAAC,CAAC;aAChF;SACJ,MAAM,IAAI,qCAAqC,CAAC,QAAQ,CAAC,EAAE;AACxD,gBAAI,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE;AACvB,uBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,sDAAsD,CAAC,CAAC;aAChF;SACJ;KACJ;;;;;;;AAOD,aAAS,QAAQ,CAAC,IAAI,EAAE;AACpB,YAAI,IAAI,CAAC,QAAQ,KAAK,GAAG,EAAE;AACvB,mBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,2CAA2C,CAAC,CAAC;SACrE;KACJ;;AAED,WAAO;AACH,8BAAsB,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,OAAO,GAAG,MAAM,GAAG,QAAQ;KAC7E,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,CAAC;CAC9B,CACJ,CAAC","file":"operator-assignment-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n * @copyright 2014 Brandon Mills. All rights reserved.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n    return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n\n/**\n * Checks whether an operator is not commuatative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is not commuatative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\"].indexOf(operator) >= 0;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n        case \"Literal\":\n            return a.value === b.value;\n        case \"MemberExpression\":\n            // x[0] = x[0]\n            // x[y] = x[y]\n            // x.y = x.y\n            return same(a.object, b.object) && same(a.property, b.property);\n        default:\n            return false;\n    }\n}\n\nmodule.exports = function(context) {\n\n    /**\n     * Ensures that an assignment uses the shorthand form where possible.\n     * @param   {ASTNode} node An AssignmentExpression node.\n     * @returns {void}\n     */\n    function verify(node) {\n        var expr, left, operator;\n\n        if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n            return;\n        }\n\n        left = node.left;\n        expr = node.right;\n        operator = expr.operator;\n\n        if (isCommutativeOperatorWithShorthand(operator)) {\n            if (same(left, expr.left) || same(left, expr.right)) {\n                context.report(node, \"Assignment can be replaced with operator assignment.\");\n            }\n        } else if (isNonCommutativeOperatorWithShorthand(operator)) {\n            if (same(left, expr.left)) {\n                context.report(node, \"Assignment can be replaced with operator assignment.\");\n            }\n        }\n    }\n\n    /**\n     * Warns if an assignment expression uses operator assignment shorthand.\n     * @param   {ASTNode} node An AssignmentExpression node.\n     * @returns {void}\n     */\n    function prohibit(node) {\n        if (node.operator !== \"=\") {\n            context.report(node, \"Unexpected operator assignment shorthand.\");\n        }\n    }\n\n    return {\n        \"AssignmentExpression\": context.options[0] !== \"never\" ? verify : prohibit\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"always\", \"never\"]\n    }\n];\n"]}