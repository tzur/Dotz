{"version":3,"sources":["no-trailing-spaces.js"],"names":[],"mappings":";;;;;AAKA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,WAAW,GAAG,wBAA4C;QAC1D,UAAU,GAAG,GAAG,GAAG,WAAW,GAAG,IAAI;QACrC,QAAQ,GAAG,WAAW,GAAG,IAAI,CAAC;;AAElC,QAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE;QAClC,cAAc,GAAG,OAAO,CAAC,cAAc,IAAI,KAAK,CAAC;;;;;;;;;AASrD,aAAS,MAAM,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE;;;;AAItC,eAAO,CAAC,MAAM,CAAC;AACX,gBAAI,EAAE,IAAI;AACV,eAAG,EAAE,QAAQ;AACb,mBAAO,EAAE,8BAA8B;AACvC,eAAG,EAAE,aAAS,KAAK,EAAE;AACjB,uBAAO,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;aACtC;SACJ,CAAC,CAAC;KACN;;;;;;AAOD,WAAO;;AAEH,iBAAS,EAAE,SAAS,mBAAmB,CAAC,IAAI,EAAE;;;;;AAK1C,gBAAI,GAAG,GAAG,OAAO,CAAC,SAAS,EAAE;gBACzB,EAAE,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC;gBACzB,SAAS,GAAG,IAAI,MAAM,CAAC,UAAU,CAAC;gBAClC,OAAO;gBAAE,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC;gBACnC,UAAU,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC,KAAK,CAAC,2BAA2B,CAAC;gBACnE,QAAQ;gBACR,WAAW,GAAG,CAAC;gBACf,QAAQ,GAAG,EAAE,CAAC;;AAElB,iBAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;AAC5C,uBAAO,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;;;;AAK5B,oBAAI,eAAe,GAAG,UAAU,IAAI,UAAU,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;AAC7E,oBAAI,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,eAAe,CAAC;;AAEnD,oBAAI,OAAO,EAAE;;;;AAIT,wBAAI,cAAc,IAAI,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;AAC5C,iCAAS;qBACZ;AACD,4BAAQ,GAAG;AACP,4BAAI,EAAE,CAAC,GAAG,CAAC;AACX,8BAAM,EAAE,OAAO,CAAC,KAAK;qBACxB,CAAC;;AAEF,4BAAQ,GAAG,CAAC,WAAW,GAAG,QAAQ,CAAC,MAAM,EAAE,WAAW,GAAG,UAAU,GAAG,eAAe,CAAC,CAAC;;AAEvF,0BAAM,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;iBACpC;;AAED,2BAAW,IAAI,UAAU,CAAC;aAC7B;SACJ;;KAEJ,CAAC;CACL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,QAAQ;AAChB,gBAAY,EAAE;AACV,wBAAgB,EAAE;AACd,kBAAM,EAAE,SAAS;SACpB;KACJ;AACD,0BAAsB,EAAE,KAAK;CAChC,CACJ,CAAC","file":"no-trailing-spaces-compiled.js","sourcesContent":["/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n * @copyright 2015 Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u2028\\u2029\\u3000]\",\n        SKIP_BLANK = \"^\" + BLANK_CLASS + \"*$\",\n        NONBLANK = BLANK_CLASS + \"+$\";\n\n    var options = context.options[0] || {},\n        skipBlankLines = options.skipBlankLines || false;\n\n    /**\n     * Report the error message\n     * @param {ASTNode} node node to report\n     * @param {int[]} location range information\n     * @param {int[]} fixRange Range based on the whole program\n     * @returns {void}\n     */\n    function report(node, location, fixRange) {\n        // Passing node is a bit dirty, because message data will contain\n        // big text in `source`. But... who cares :) ?\n        // One more kludge will not make worse the bloody wizardry of this plugin.\n        context.report({\n            node: node,\n            loc: location,\n            message: \"Trailing spaces not allowed.\",\n            fix: function(fixer) {\n                return fixer.removeRange(fixRange);\n            }\n        });\n    }\n\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n\n        \"Program\": function checkTrailingSpaces(node) {\n\n            // Let's hack. Since Espree does not return whitespace nodes,\n            // fetch the source code and do matching via regexps.\n\n            var src = context.getSource(),\n                re = new RegExp(NONBLANK),\n                skipMatch = new RegExp(SKIP_BLANK),\n                matches, lines = src.split(/\\r?\\n/),\n                linebreaks = context.getSource().match(/\\r\\n|\\r|\\n|\\u2028|\\u2029/g),\n                location,\n                totalLength = 0,\n                fixRange = [];\n\n            for (var i = 0, ii = lines.length; i < ii; i++) {\n                matches = re.exec(lines[i]);\n\n                // Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                // Because during the fix time they also reserve one spot in the array.\n                // Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                var linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                var lineLength = lines[i].length + linebreakLength;\n\n                if (matches) {\n\n                    // If the line has only whitespace, and skipBlankLines\n                    // is true, don't report it\n                    if (skipBlankLines && skipMatch.test(lines[i])) {\n                        continue;\n                    }\n                    location = {\n                        line: i + 1,\n                        column: matches.index\n                    };\n\n                    fixRange = [totalLength + location.column, totalLength + lineLength - linebreakLength];\n\n                    report(node, location, fixRange);\n                }\n\n                totalLength += lineLength;\n            }\n        }\n\n    };\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"skipBlankLines\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}