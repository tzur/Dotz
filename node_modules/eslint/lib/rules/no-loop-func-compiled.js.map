{"version":3,"sources":["no-loop-func.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;;;;;;;;;;;;;;AAeb,SAAS,qBAAqB,CAAC,IAAI,EAAE;AACjC,QAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;AACzB,WAAO,MAAM,EAAE;AACX,gBAAQ,MAAM,CAAC,IAAI;AACf,iBAAK,gBAAgB,CAAC;AACtB,iBAAK,kBAAkB;AACnB,uBAAO,MAAM,CAAC;;AAAA,AAElB,iBAAK,cAAc;;AAEf,oBAAI,MAAM,CAAC,IAAI,KAAK,IAAI,EAAE;AACtB,2BAAO,MAAM,CAAC;iBACjB;AACD,sBAAM;;AAAA,AAEV,iBAAK,gBAAgB,CAAC;AACtB,iBAAK,gBAAgB;;AAEjB,oBAAI,MAAM,CAAC,KAAK,KAAK,IAAI,EAAE;AACvB,2BAAO,MAAM,CAAC;iBACjB;AACD,sBAAM;;AAAA,AAEV,iBAAK,yBAAyB,CAAC;AAC/B,iBAAK,oBAAoB,CAAC;AAC1B,iBAAK,qBAAqB;;AAEtB,uBAAO,IAAI,CAAC;;AAAA,AAEhB;AACI,sBAAM;AAAA,SACb;;AAED,YAAI,GAAG,MAAM,CAAC;AACd,cAAM,GAAG,IAAI,CAAC,MAAM,CAAC;KACxB;;AAED,WAAO,IAAI,CAAC;CACf;;;;;;;;AAQD,SAAS,qBAAqB,CAAC,QAAQ,EAAE,SAAS,EAAE;;AAEhD,QAAI,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC;AAClC,QAAI,UAAU,GAAG,QAAQ,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC9C,QAAI,WAAW,GAAG,UAAU,IAAI,UAAU,CAAC,MAAM,CAAC;;AAElD;;AAEI,mBAAW,IACX,WAAW,CAAC,IAAI,KAAK,qBAAqB,KACzC,WAAW,CAAC,IAAI,KAAK,KAAK,IAAI,WAAW,CAAC,IAAI,KAAK,OAAO,CAAA,AAAC;;AAE5D,mBAAW,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,IACxC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;MAC1C;CACL;;;;;;AAMD,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;;;;;;;;;AAU/B,aAAS,aAAa,CAAC,IAAI,EAAE;AACzB,YAAI,QAAQ,GAAG,qBAAqB,CAAC,IAAI,CAAC,CAAC;AAC3C,YAAI,CAAC,QAAQ,EAAE;AACX,mBAAO;SACV;;AAED,YAAI,UAAU,GAAG,OAAO,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC;AAC5C,YAAI,UAAU,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,EAAE;AACxF,mBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,oCAAoC,CAAC,CAAC;SAC9D;KACJ;;AAED,WAAO;AACH,iCAAyB,EAAE,aAAa;AACxC,4BAAoB,EAAE,aAAa;AACnC,6BAAqB,EAAE,aAAa;KACvC,CAAC;CACL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"no-loop-func-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n * @copyright 2013 Ilya Volodin. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n *\n * @param {ASTNode} node - An AST node to get.\n * @returns {ASTNode|null} The containing loop node of the specified node, or `null`.\n */\nfunction getContainingLoopNode(node) {\n    var parent = node.parent;\n    while (parent) {\n        switch (parent.type) {\n            case \"WhileStatement\":\n            case \"DoWhileStatement\":\n                return parent;\n\n            case \"ForStatement\":\n                // `init` is outside of the loop.\n                if (parent.init !== node) {\n                    return parent;\n                }\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                // `right` is outside of the loop.\n                if (parent.right !== node) {\n                    return parent;\n                }\n                break;\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n            case \"FunctionDeclaration\":\n                // We don't need to check nested functions.\n                return null;\n\n            default:\n                break;\n        }\n\n        node = parent;\n        parent = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether or not a reference refers to a variable that is block-binding in the loop.\n * @param {ASTNode} loopNode - A containing loop node.\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} Whether or not a reference refers to a variable that is block-binding in the loop.\n */\nfunction isBlockBindingsInLoop(loopNode, reference) {\n    // A reference to a `let`/`const` variable always has a resolved variable.\n    var variable = reference.resolved;\n    var definition = variable && variable.defs[0];\n    var declaration = definition && definition.parent;\n\n    return (\n        // Checks whether this is `let`/`const`.\n        declaration &&\n        declaration.type === \"VariableDeclaration\" &&\n        (declaration.kind === \"let\" || declaration.kind === \"const\") &&\n        // Checks whether this is in the loop.\n        declaration.range[0] > loopNode.range[0] &&\n        declaration.range[1] < loopNode.range[1]\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    /**\n     * Reports such functions:\n     *\n     * - has an ancestor node which is a loop.\n     * - has a reference that refers to a variable that is block-binding in the loop.\n     *\n     * @param {ASTNode} node The AST node to check.\n     * @returns {boolean} Whether or not the node is within a loop.\n     */\n    function checkForLoops(node) {\n        var loopNode = getContainingLoopNode(node);\n        if (!loopNode) {\n            return;\n        }\n\n        var references = context.getScope().through;\n        if (references.length > 0 && !references.every(isBlockBindingsInLoop.bind(null, loopNode))) {\n            context.report(node, \"Don't make functions within a loop\");\n        }\n    }\n\n    return {\n        \"ArrowFunctionExpression\": checkForLoops,\n        \"FunctionExpression\": checkForLoops,\n        \"FunctionDeclaration\": checkForLoops\n    };\n};\n\nmodule.exports.schema = [];\n"]}