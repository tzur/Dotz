{"version":3,"sources":["space-unary-ops.js"],"names":[],"mappings":"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","file":"space-unary-ops-compiled.js","sourcesContent":["/**\n * @fileoverview This rule shoud require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n * @copyright 2014 Marcin Kumorek. All rights reserved.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    var options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n    * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n    * @param {ASTnode} node AST node\n    * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n    */\n    function isFirstBangInBangBangExpression(node) {\n        return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n            node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n    }\n\n    /**\n    * Check if the node's child argument is an \"ObjectExpression\"\n    * @param {ASTnode} node AST node\n    * @returns {boolean} Whether or not the argument's type is \"ObjectExpression\"\n    */\n    function isArgumentObjectExpression(node) {\n        return node.argument && node.argument.type && node.argument.type === \"ObjectExpression\";\n    }\n\n    /**\n    * Check Unary Word Operators for spaces after the word operator\n    * @param {ASTnode} node AST node\n    * @param {object} firstToken first token from the AST node\n    * @param {object} secondToken second token from the AST node\n    * @param {string} word The word to be used for reporting\n    * @returns {void}\n    */\n    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n        word = word || firstToken.value;\n\n        if (options.words) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node: node,\n                    message: \"Unary word operator \\\"\" + word + \"\\\" must be followed by whitespace.\",\n                    fix: function(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        if (!options.words && isArgumentObjectExpression(node)) {\n            if (secondToken.range[0] > firstToken.range[1]) {\n                context.report({\n                    node: node,\n                    message: \"Unexpected space after unary word operator \\\"\" + word + \"\\\".\",\n                    fix: function(fixer) {\n                        return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                    }\n                });\n            }\n        }\n    }\n\n    /**\n    * Checks UnaryExpression, UpdateExpression and NewExpression for spaces before and after the operator\n    * @param {ASTnode} node AST node\n    * @returns {void}\n    */\n    function checkForSpaces(node) {\n        var tokens = context.getFirstTokens(node, 2),\n            firstToken = tokens[0],\n            secondToken = tokens[1];\n\n        if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n            checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);\n            return void 0;\n        }\n\n        if (options.nonwords) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return void 0;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node: node,\n                        message: \"Unary operator \\\"\" + firstToken.value + \"\\\" must be followed by whitespace.\",\n                        fix: function(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node: node,\n                        message: \"Space is required before unary expressions \\\"\" + secondToken.value + \"\\\".\",\n                        fix: function(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        } else {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node: node,\n                        message: \"Unexpected space after unary operator \\\"\" + firstToken.value + \"\\\".\",\n                        fix: function(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node: node,\n                        message: \"Unexpected space before unary operator \\\"\" + secondToken.value + \"\\\".\",\n                        fix: function(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        \"UnaryExpression\": checkForSpaces,\n        \"UpdateExpression\": checkForSpaces,\n        \"NewExpression\": checkForSpaces,\n        \"YieldExpression\": function(node) {\n            var tokens = context.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument) {\n                return;\n            }\n\n            if (node.delegate) {\n                word += \"*\";\n                checkUnaryWordOperatorForSpaces(node, tokens[1], tokens[2], word);\n            } else {\n                checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n            }\n        }\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"words\": {\n                \"type\": \"boolean\"\n            },\n            \"nonwords\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}