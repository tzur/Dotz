{"version":3,"sources":["space-after-keywords.js"],"names":[],"mappings":"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","file":"space-after-keywords-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to enforce the number of spaces after certain keywords\n * @author Nick Fisher\n * @copyright 2014 Nick Fisher. All rights reserved.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    // unless the first option is `\"never\"`, then a space is required\n    var requiresSpace = context.options[0] !== \"never\";\n\n    /**\n     * Check if the separation of two adjacent tokens meets the spacing rules, and report a problem if not.\n     *\n     * @param {ASTNode} node  The node to which the potential problem belongs.\n     * @param {Token} left    The first token.\n     * @param {Token} right   The second token\n     * @returns {void}\n     */\n    function checkTokens(node, left, right) {\n        if (right.type !== \"Punctuator\") {\n            return;\n        }\n\n        var hasSpace = left.range[1] < right.range[0],\n            value = left.value;\n\n        if (hasSpace !== requiresSpace) {\n            context.report({\n                node: node,\n                message: \"Keyword \\\"{{value}}\\\" must {{not}}be followed by whitespace.\",\n                data: {\n                    value: value,\n                    not: requiresSpace ? \"\" : \"not \"\n                },\n                fix: function(fixer) {\n                    if (requiresSpace) {\n                        return fixer.insertTextAfter(left, \" \");\n                    } else {\n                        return fixer.removeRange([left.range[1], right.range[0]]);\n                    }\n                }\n            });\n        } else if (left.loc.end.line !== right.loc.start.line) {\n            context.report({\n                node: node,\n                message: \"Keyword \\\"{{value}}\\\" must not be followed by a newline.\",\n                data: {\n                    value: value\n                },\n                fix: function(fixer) {\n                    var text = \"\";\n                    if (requiresSpace) {\n                        text = \" \";\n                    }\n                    return fixer.replaceTextRange([left.range[1], right.range[0]], text);\n                }\n            });\n        }\n    }\n\n    /**\n     * Check if the given node (`if`, `for`, `while`, etc), has the correct spacing after it.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n    function check(node) {\n        var tokens = context.getFirstTokens(node, 2);\n        checkTokens(node, tokens[0], tokens[1]);\n    }\n\n    return {\n        \"IfStatement\": function(node) {\n            check(node);\n            // check the `else`\n            if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                checkTokens(node.alternate, context.getTokenBefore(node.alternate), context.getFirstToken(node.alternate));\n            }\n        },\n        \"ForStatement\": check,\n        \"ForOfStatement\": check,\n        \"ForInStatement\": check,\n        \"WhileStatement\": check,\n        \"DoWhileStatement\": function(node) {\n            check(node);\n            // check the `while`\n            var whileTokens = context.getTokensAfter(node.body, 2);\n            checkTokens(node, whileTokens[0], whileTokens[1]);\n        },\n        \"SwitchStatement\": check,\n        \"TryStatement\": function(node) {\n            check(node);\n            // check the `finally`\n            if (node.finalizer) {\n                checkTokens(node.finalizer, context.getTokenBefore(node.finalizer), context.getFirstToken(node.finalizer));\n            }\n        },\n        \"CatchClause\": check,\n        \"WithStatement\": check\n    };\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"always\", \"never\"]\n    }\n];\n"]}