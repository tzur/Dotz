{"version":3,"sources":["no-unexpected-multiline.js"],"names":[],"mappings":";;;;;AAKA,YAAY,CAAC;;;;;AAKb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,gBAAgB,GAAG,6DAA6D,CAAC;AACrF,QAAI,gBAAgB,GAAG,6DAA6D,CAAC;;;;;;;;;;AAUrF,aAAS,mBAAmB,CAAC,IAAI,EAAE,GAAG,EAAE;AACpC,YAAI,MAAM,GAAG,OAAO,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;AAC9C,YAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACtB,YAAI,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,YAAI,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE;AAC9C,mBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;SACrE;KACJ;;;;;;AAMD,WAAO;;AAEH,0BAAkB,EAAE,0BAAS,IAAI,EAAE;AAC/B,gBAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;AAChB,uBAAO;aACV;;AAED,+BAAmB,CAAC,IAAI,CAAC,QAAQ,EAAE,gBAAgB,CAAC,CAAC;SACxD;;AAED,wBAAgB,EAAE,wBAAS,IAAI,EAAE;AAC7B,gBAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC7B,uBAAO;aACV;;AAED,+BAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC;SAC5D;KACJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"no-unexpected-multiline-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to spot scenarios where a newline looks like it is ending a statement, but is not.\n * @author Glen Mailer\n * @copyright 2015 Glen Mailer\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = function(context) {\n\n    var FUNCTION_MESSAGE = \"Unexpected newline between function and ( of function call.\";\n    var PROPERTY_MESSAGE = \"Unexpected newline between object and [ of property access.\";\n\n    /**\n     * Check to see if the bracket prior to the node is continuing the previous\n     * line's expression\n     * @param {ASTNode} node The node to check.\n     * @param {string} msg The error message to use.\n     * @returns {void}\n     * @private\n     */\n    function checkForBreakBefore(node, msg) {\n        var tokens = context.getTokensBefore(node, 2);\n        var paren = tokens[1];\n        var before = tokens[0];\n        if (paren.loc.start.line !== before.loc.end.line) {\n            context.report(node, paren.loc.start, msg, { char: paren.value });\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n\n        \"MemberExpression\": function(node) {\n            if (!node.computed) {\n                return;\n            }\n\n            checkForBreakBefore(node.property, PROPERTY_MESSAGE);\n        },\n\n        \"CallExpression\": function(node) {\n            if (node.arguments.length === 0) {\n                return;\n            }\n\n            checkForBreakBefore(node.arguments[0], FUNCTION_MESSAGE);\n        }\n    };\n\n};\n\nmodule.exports.schema = [];\n"]}