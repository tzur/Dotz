{"version":3,"sources":["no-extra-parens.js"],"names":[],"mappings":"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","file":"no-extra-parens-compiled.js","sourcesContent":["/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n * @copyright 2014 Michael Ficarra. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var ALL_NODES = context.options[0] !== \"functions\";\n\n    /**\n     * Determines if this rule should be enforced for a node given the current configuration.\n     * @param {ASTNode} node - The node to be checked.\n     * @returns {boolean} True if the rule should be enforced for this node.\n     * @private\n     */\n    function ruleApplies(node) {\n        return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n    }\n\n    /**\n     * Determines if a node is surrounded by parentheses.\n     * @param {ASTNode} node - The node to be checked.\n     * @returns {boolean} True if the node is parenthesised.\n     * @private\n     */\n    function isParenthesised(node) {\n        var previousToken = context.getTokenBefore(node),\n            nextToken = context.getTokenAfter(node);\n\n        return previousToken && nextToken &&\n            previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n            nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n    }\n\n    /**\n     * Determines if a node is surrounded by parentheses twice.\n     * @param {ASTNode} node - The node to be checked.\n     * @returns {boolean} True if the node is doubly parenthesised.\n     * @private\n     */\n    function isParenthesisedTwice(node) {\n        var previousToken = context.getTokenBefore(node, 1),\n            nextToken = context.getTokenAfter(node, 1);\n\n        return isParenthesised(node) && previousToken && nextToken &&\n            previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n            nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n    }\n\n    /**\n     * Determines if a node is surrounded by (potentially) invalid parentheses.\n     * @param {ASTNode} node - The node to be checked.\n     * @returns {boolean} True if the node is incorrectly parenthesised.\n     * @private\n     */\n    function hasExcessParens(node) {\n        return ruleApplies(node) && isParenthesised(node);\n    }\n\n    /**\n     * Determines if a node that is expected to be parenthesised is surrounded by\n     * (potentially) invalid extra parentheses.\n     * @param {ASTNode} node - The node to be checked.\n     * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n     * @private\n     */\n    function hasDoubleExcessParens(node) {\n        return ruleApplies(node) && isParenthesisedTwice(node);\n    }\n\n    /**\n     * Checks whether or not a given node is located at the head of ExpressionStatement.\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is located at the head of ExpressionStatement.\n     */\n    function isHeadOfExpressionStatement(node) {\n        var parent = node.parent;\n        while (parent) {\n            switch (parent.type) {\n                case \"SequenceExpression\":\n                    if (parent.expressions[0] !== node || isParenthesised(node)) {\n                        return false;\n                    }\n                    break;\n\n                case \"UnaryExpression\":\n                case \"UpdateExpression\":\n                    if (parent.prefix || isParenthesised(node)) {\n                        return false;\n                    }\n                    break;\n\n                case \"BinaryExpression\":\n                case \"LogicalExpression\":\n                    if (parent.left !== node || isParenthesised(node)) {\n                        return false;\n                    }\n                    break;\n\n                case \"ConditionalExpression\":\n                    if (parent.test !== node || isParenthesised(node)) {\n                        return false;\n                    }\n                    break;\n\n                case \"CallExpression\":\n                    if (parent.callee !== node || isParenthesised(node)) {\n                        return false;\n                    }\n                    break;\n\n                case \"MemberExpression\":\n                    if (parent.object !== node || isParenthesised(node)) {\n                        return false;\n                    }\n                    break;\n\n                case \"ExpressionStatement\":\n                    return true;\n\n                default:\n                    return false;\n            }\n\n            node = parent;\n            parent = parent.parent;\n        }\n\n        /* istanbul ignore next */\n        throw new Error(\"unreachable\");\n    }\n\n    /**\n     * Get the precedence level based on the node type\n     * @param {ASTNode} node node to evaluate\n     * @returns {int} precedence level\n     * @private\n     */\n    function precedence(node) {\n\n        switch (node.type) {\n            case \"SequenceExpression\":\n                return 0;\n\n            case \"AssignmentExpression\":\n            case \"ArrowFunctionExpression\":\n            case \"YieldExpression\":\n                return 1;\n\n            case \"ConditionalExpression\":\n                return 3;\n\n            case \"LogicalExpression\":\n                switch (node.operator) {\n                    case \"||\":\n                        return 4;\n                    case \"&&\":\n                        return 5;\n                    // no default\n                }\n\n                /* falls through */\n            case \"BinaryExpression\":\n                switch (node.operator) {\n                    case \"|\":\n                        return 6;\n                    case \"^\":\n                        return 7;\n                    case \"&\":\n                        return 8;\n                    case \"==\":\n                    case \"!=\":\n                    case \"===\":\n                    case \"!==\":\n                        return 9;\n                    case \"<\":\n                    case \"<=\":\n                    case \">\":\n                    case \">=\":\n                    case \"in\":\n                    case \"instanceof\":\n                        return 10;\n                    case \"<<\":\n                    case \">>\":\n                    case \">>>\":\n                        return 11;\n                    case \"+\":\n                    case \"-\":\n                        return 12;\n                    case \"*\":\n                    case \"/\":\n                    case \"%\":\n                        return 13;\n                    // no default\n                }\n                /* falls through */\n            case \"UnaryExpression\":\n                return 14;\n            case \"UpdateExpression\":\n                return 15;\n            case \"CallExpression\":\n                // IIFE is allowed to have parens in any position (#655)\n                if (node.callee.type === \"FunctionExpression\") {\n                    return -1;\n                }\n                return 16;\n            case \"NewExpression\":\n                return 17;\n            // no default\n        }\n        return 18;\n    }\n\n    /**\n     * Report the node\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function report(node) {\n        var previousToken = context.getTokenBefore(node);\n        context.report(node, previousToken.loc.start, \"Gratuitous parentheses around expression.\");\n    }\n\n    /**\n     * Evaluate Unary update\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function dryUnaryUpdate(node) {\n        if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {\n            report(node.argument);\n        }\n    }\n\n    /**\n     * Evaluate a new call\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function dryCallNew(node) {\n        if (hasExcessParens(node.callee) && precedence(node.callee) >= precedence(node) && !(\n            node.type === \"CallExpression\" &&\n            node.callee.type === \"FunctionExpression\" &&\n            // One set of parentheses are allowed for a function expression\n            !hasDoubleExcessParens(node.callee)\n        )) {\n            report(node.callee);\n        }\n        if (node.arguments.length === 1) {\n            if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= precedence({type: \"AssignmentExpression\"})) {\n                report(node.arguments[0]);\n            }\n        } else {\n            [].forEach.call(node.arguments, function(arg) {\n                if (hasExcessParens(arg) && precedence(arg) >= precedence({type: \"AssignmentExpression\"})) {\n                    report(arg);\n                }\n            });\n        }\n    }\n\n    /**\n     * Evaluate binary logicals\n     * @param {ASTNode} node node to evaluate\n     * @returns {void}\n     * @private\n     */\n    function dryBinaryLogical(node) {\n        var prec = precedence(node);\n        if (hasExcessParens(node.left) && precedence(node.left) >= prec) {\n            report(node.left);\n        }\n        if (hasExcessParens(node.right) && precedence(node.right) > prec) {\n            report(node.right);\n        }\n    }\n\n    return {\n        \"ArrayExpression\": function(node) {\n            [].forEach.call(node.elements, function(e) {\n                if (e && hasExcessParens(e) && precedence(e) >= precedence({type: \"AssignmentExpression\"})) {\n                    report(e);\n                }\n            });\n        },\n        \"ArrowFunctionExpression\": function(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                if (node.body.type !== \"ObjectExpression\" && hasExcessParens(node.body) && precedence(node.body) >= precedence({type: \"AssignmentExpression\"})) {\n                    report(node.body);\n                    return;\n                }\n\n                // Object literals *must* be parenthesized\n                if (node.body.type === \"ObjectExpression\" && hasDoubleExcessParens(node.body)) {\n                    report(node.body);\n                    return;\n                }\n            }\n        },\n        \"AssignmentExpression\": function(node) {\n            if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {\n                report(node.right);\n            }\n        },\n        \"BinaryExpression\": dryBinaryLogical,\n        \"CallExpression\": dryCallNew,\n        \"ConditionalExpression\": function(node) {\n            if (hasExcessParens(node.test) && precedence(node.test) >= precedence({type: \"LogicalExpression\", operator: \"||\"})) {\n                report(node.test);\n            }\n            if (hasExcessParens(node.consequent) && precedence(node.consequent) >= precedence({type: \"AssignmentExpression\"})) {\n                report(node.consequent);\n            }\n            if (hasExcessParens(node.alternate) && precedence(node.alternate) >= precedence({type: \"AssignmentExpression\"})) {\n                report(node.alternate);\n            }\n        },\n        \"DoWhileStatement\": function(node) {\n            if (hasDoubleExcessParens(node.test)) {\n                report(node.test);\n            }\n        },\n        \"ExpressionStatement\": function(node) {\n            var firstToken;\n            if (hasExcessParens(node.expression)) {\n                firstToken = context.getFirstToken(node.expression);\n\n                // Pure object literals ({}) do not need parentheses but\n                // member expressions do ({}.toString())\n                if ((\n                        firstToken.value !== \"{\" ||\n                        node.expression.type === \"ObjectExpression\"\n                    ) &&\n                    // For such as `(function(){}.foo.bar)`\n                    (\n                        firstToken.value !== \"function\" ||\n                        node.expression.type === \"FunctionExpression\"\n                    ) &&\n                    // For such as `(class{}.foo.bar)`\n                    (\n                        firstToken.value !== \"class\" ||\n                        node.expression.type === \"ClassExpression\"\n                    )\n                ) {\n                    report(node.expression);\n                }\n            }\n        },\n        \"ForInStatement\": function(node) {\n            if (hasExcessParens(node.right)) {\n                report(node.right);\n            }\n        },\n        \"ForOfStatement\": function(node) {\n            if (hasExcessParens(node.right)) {\n                report(node.right);\n            }\n        },\n        \"ForStatement\": function(node) {\n            if (node.init && hasExcessParens(node.init)) {\n                report(node.init);\n            }\n\n            if (node.test && hasExcessParens(node.test)) {\n                report(node.test);\n            }\n\n            if (node.update && hasExcessParens(node.update)) {\n                report(node.update);\n            }\n        },\n        \"IfStatement\": function(node) {\n            if (hasDoubleExcessParens(node.test)) {\n                report(node.test);\n            }\n        },\n        \"LogicalExpression\": dryBinaryLogical,\n        \"MemberExpression\": function(node) {\n            if (\n                hasExcessParens(node.object) &&\n                precedence(node.object) >= precedence(node) &&\n                (\n                    node.computed ||\n                    !(\n                        (node.object.type === \"Literal\" &&\n                        typeof node.object.value === \"number\" &&\n                        /^[0-9]+$/.test(context.getFirstToken(node.object).value))\n                        ||\n                        // RegExp literal is allowed to have parens (#1589)\n                        (node.object.type === \"Literal\" && node.object.regex)\n                    )\n                ) &&\n                !(\n                    (node.object.type === \"FunctionExpression\" || node.object.type === \"ClassExpression\") &&\n                    isHeadOfExpressionStatement(node) &&\n                    !hasDoubleExcessParens(node.object)\n                )\n            ) {\n                report(node.object);\n            }\n            if (node.computed && hasExcessParens(node.property)) {\n                report(node.property);\n            }\n        },\n        \"NewExpression\": dryCallNew,\n        \"ObjectExpression\": function(node) {\n            [].forEach.call(node.properties, function(e) {\n                var v = e.value;\n                if (v && hasExcessParens(v) && precedence(v) >= precedence({type: \"AssignmentExpression\"})) {\n                    report(v);\n                }\n            });\n        },\n        \"ReturnStatement\": function(node) {\n            if (node.argument && hasExcessParens(node.argument) &&\n                    // RegExp literal is allowed to have parens (#1589)\n                    !(node.argument.type === \"Literal\" && node.argument.regex)) {\n                report(node.argument);\n            }\n        },\n        \"SequenceExpression\": function(node) {\n            [].forEach.call(node.expressions, function(e) {\n                if (hasExcessParens(e) && precedence(e) >= precedence(node)) {\n                    report(e);\n                }\n            });\n        },\n        \"SwitchCase\": function(node) {\n            if (node.test && hasExcessParens(node.test)) {\n                report(node.test);\n            }\n        },\n        \"SwitchStatement\": function(node) {\n            if (hasDoubleExcessParens(node.discriminant)) {\n                report(node.discriminant);\n            }\n        },\n        \"ThrowStatement\": function(node) {\n            if (hasExcessParens(node.argument)) {\n                report(node.argument);\n            }\n        },\n        \"UnaryExpression\": dryUnaryUpdate,\n        \"UpdateExpression\": dryUnaryUpdate,\n        \"VariableDeclarator\": function(node) {\n            if (node.init && hasExcessParens(node.init) &&\n                    precedence(node.init) >= precedence({type: \"AssignmentExpression\"}) &&\n                    // RegExp literal is allowed to have parens (#1589)\n                    !(node.init.type === \"Literal\" && node.init.regex)) {\n                report(node.init);\n            }\n        },\n        \"WhileStatement\": function(node) {\n            if (hasDoubleExcessParens(node.test)) {\n                report(node.test);\n            }\n        },\n        \"WithStatement\": function(node) {\n            if (hasDoubleExcessParens(node.object)) {\n                report(node.object);\n            }\n        }\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"all\", \"functions\"]\n    }\n];\n"]}