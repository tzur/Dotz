{"version":3,"sources":["no-invalid-this.js"],"names":[],"mappings":"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","file":"no-invalid-this-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar thisTagPattern = /^[\\s\\*]*@this/m;\nvar anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;\nvar bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;\nvar arrayOrTypedArrayPattern = /Array$/;\nvar arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node - A function node to check.\n * @returns {boolean} Wehether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n    return (\n        node.id &&\n        node.id.name[0] === node.id.name[0].toLocaleUpperCase()\n    );\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node - A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n    while (node) {\n        if (anyFunctionPattern.test(node.type)) {\n            return node;\n        }\n        node = node.parent;\n    }\n    return null;\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Checks whether or not a node is `Reclect.apply`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Reclect.apply`.\n */\nfunction isReflectApply(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        node.object.name === \"Reflect\" &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"apply\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFrom(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        arrayOrTypedArrayPattern.test(node.object.name) &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"from\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is a method which has `thisArg`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\n */\nfunction isMethodWhichHasThisArg(node) {\n    while (node) {\n        if (node.type === \"Identifier\") {\n            return arrayMethodPattern.test(node.name);\n        }\n        if (node.type === \"MemberExpression\" && !node.computed) {\n            node = node.property;\n            continue;\n        }\n\n        break;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    var stack = [],\n        sourceCode = context.getSourceCode();\n\n\n    /**\n     * Checks whether or not a node has a `@this` tag in its comments.\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n     */\n    function hasJSDocThisTag(node) {\n        var jsdocComment = sourceCode.getJSDocComment(node);\n        if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n            return true;\n        }\n\n        // Checks `@this` in its leading comments for callbacks,\n        // because callbacks don't have its JSDoc comment.\n        // e.g.\n        //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n        return sourceCode.getComments(node).leading.some(function(comment) {\n            return thisTagPattern.test(comment.value);\n        });\n    }\n\n    /**\n     * Checks whether or not a node has valid `this`.\n     *\n     * First, this checks the node:\n     *\n     * - The function name starts with uppercase (it's a constructor).\n     * - The function has a JSDoc comment that has a @this tag.\n     *\n     * Next, this checks the location of the node.\n     * If the location is below, this judges `this` is valid.\n     *\n     * - The location is on an object literal.\n     * - The location assigns to a property.\n     * - The location is on an ES2015 class.\n     * - The location calls its `bind`/`call`/`apply` method directly.\n     * - The function is a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n     *\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} A found function node.\n     */\n    function hasValidThis(node) {\n        if (isES5Constructor(node) || hasJSDocThisTag(node)) {\n            return true;\n        }\n\n        while (node) {\n            var parent = node.parent;\n            switch (parent.type) {\n                // Looks up the destination.\n                // e.g.\n                //   obj.foo = nativeFoo || function foo() { ... };\n                case \"LogicalExpression\":\n                case \"ConditionalExpression\":\n                    node = parent;\n                    break;\n\n                // If the upper function is IIFE, checks the destination of the return value.\n                // e.g.\n                //   obj.foo = (function() {\n                //     // setup...\n                //     return function foo() { ... };\n                //   })();\n                case \"ReturnStatement\":\n                    var func = getUpperFunction(parent);\n                    if (func === null || !isCallee(func)) {\n                        return false;\n                    }\n                    node = func.parent;\n                    break;\n\n                // e.g.\n                //   var obj = { foo() { ... } };\n                //   var obj = { foo: function() { ... } };\n                case \"Property\":\n                    return true;\n\n                // e.g.\n                //   obj.foo = foo() { ... };\n                case \"AssignmentExpression\":\n                    return (\n                        parent.right === node &&\n                        parent.left.type === \"MemberExpression\"\n                    );\n\n                // e.g.\n                //   class A { constructor() { ... } }\n                //   class A { foo() { ... } }\n                //   class A { get foo() { ... } }\n                //   class A { set foo() { ... } }\n                //   class A { static foo() { ... } }\n                case \"MethodDefinition\":\n                    return !parent.static;\n\n                // e.g.\n                //   var foo = function foo() { ... }.bind(obj);\n                //   (function foo() { ... }).call(obj);\n                //   (function foo() { ... }).apply(obj, []);\n                case \"MemberExpression\":\n                    return (\n                        parent.object === node &&\n                        parent.property.type === \"Identifier\" &&\n                        bindOrCallOrApplyPattern.test(parent.property.name) &&\n                        isCallee(parent) &&\n                        parent.parent.arguments.length > 0 &&\n                        !astUtils.isNullOrUndefined(parent.parent.arguments[0])\n                    );\n\n                // e.g.\n                //   Reflect.apply(function() {}, obj, []);\n                //   Array.from([], function() {}, obj);\n                //   list.forEach(function() {}, obj);\n                case \"CallExpression\":\n                    if (isReflectApply(parent.callee)) {\n                        return (\n                            parent.arguments.length === 3 &&\n                            parent.arguments[0] === node &&\n                            !astUtils.isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    if (isArrayFrom(parent.callee)) {\n                        return (\n                            parent.arguments.length === 3 &&\n                            parent.arguments[1] === node &&\n                            !astUtils.isNullOrUndefined(parent.arguments[2])\n                        );\n                    }\n                    if (isMethodWhichHasThisArg(parent.callee)) {\n                        return (\n                            parent.arguments.length === 2 &&\n                            parent.arguments[0] === node &&\n                            !astUtils.isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    return false;\n\n                // Otherwise `this` is invalid.\n                default:\n                    return false;\n            }\n        }\n\n        /* istanbul ignore next */\n        throw new Error(\"unreachable\");\n    }\n\n    /**\n     * Gets the current checking context.\n     *\n     * The return value has a flag that whether or not `this` keyword is valid.\n     * The flag is initialized when got at the first time.\n     *\n     * @returns {{valid: boolean}}\n     *   an object which has a flag that whether or not `this` keyword is valid.\n     */\n    stack.getCurrent = function() {\n        var current = this[this.length - 1];\n        if (!current.init) {\n            current.init = true;\n            current.valid = hasValidThis(current.node);\n        }\n        return current;\n    };\n\n    /**\n     * Pushs new checking context into the stack.\n     *\n     * The checking context is not initialized yet.\n     * Because most functions don't have `this` keyword.\n     * When `this` keyword was found, the checking context is initialized.\n     *\n     * @param {ASTNode} node - A function node that was entered.\n     * @returns {void}\n     */\n    function enterFunction(node) {\n        // `this` can be invalid only under strict mode.\n        stack.push({\n            init: !context.getScope().isStrict,\n            node: node,\n            valid: true\n        });\n    }\n\n    /**\n     * Pops the current checking context from the stack.\n     * @returns {void}\n     */\n    function exitFunction() {\n        stack.pop();\n    }\n\n    return {\n        // `this` is invalid only under strict mode.\n        // Modules is always strict mode.\n        \"Program\": function(node) {\n            var scope = context.getScope();\n            var features = context.ecmaFeatures;\n\n            stack.push({\n                init: true,\n                node: node,\n                valid: !(\n                    scope.isStrict ||\n                    features.modules ||\n                    (features.globalReturn && scope.childScopes[0].isStrict)\n                )\n            });\n        },\n        \"Program:exit\": function() {\n            stack.pop();\n        },\n\n        \"FunctionDeclaration\": enterFunction,\n        \"FunctionDeclaration:exit\": exitFunction,\n        \"FunctionExpression\": enterFunction,\n        \"FunctionExpression:exit\": exitFunction,\n\n        // Reports if `this` of the current context is invalid.\n        \"ThisExpression\": function(node) {\n            var current = stack.getCurrent();\n            if (current && !current.valid) {\n                context.report(node, \"Unexpected `this`.\");\n            }\n        }\n    };\n};\n\nmodule.exports.schema = [];\n"]}