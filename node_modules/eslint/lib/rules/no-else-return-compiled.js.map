{"version":3,"sources":["no-else-return.js"],"names":[],"mappings":";;;;;AAKA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;;;;;;;;;;;AAY/B,aAAS,aAAa,CAAC,IAAI,EAAE;AACzB,eAAO,CAAC,MAAM,CAAC,IAAI,EAAE,mCAAmC,CAAC,CAAC;KAC7D;;;;;;;;AAQD,aAAS,cAAc,CAAC,IAAI,EAAE;AAC1B,eAAO,IAAI,CAAC,IAAI,KAAK,iBAAiB,CAAC;KAC1C;;;;;;;;;;AAUD,aAAS,cAAc,CAAC,IAAI,EAAE;AAC1B,YAAI,IAAI,CAAC,IAAI,KAAK,gBAAgB,EAAE;AAChC,gBAAI,IAAI,GAAG,IAAI,CAAC,IAAI;gBAChB,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;;AAE1C,mBAAO,aAAa,IAAI,cAAc,CAAC,aAAa,CAAC,CAAC;SACzD;AACD,eAAO,cAAc,CAAC,IAAI,CAAC,CAAC;KAC/B;;;;;;;;;AASD,aAAS,OAAO,CAAC,IAAI,EAAE;AACnB,eAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,aAAa,CAAC;KACrF;;;;;;;;;;AAUD,aAAS,UAAU,CAAC,IAAI,EAAE;AACtB,eAAO,IAAI,CAAC,IAAI,KAAK,aAAa,IAAI,OAAO,CAAC,IAAI,CAAC,IAC/C,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;KACzE;;;;;;;;;;;AAWD,aAAS,kBAAkB,CAAC,IAAI,EAAE;AAC9B,eAAO,cAAc,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;KACnD;;;;;;;AAQD,aAAS,aAAa,CAAC,IAAI,EAAE;;AAEzB,YAAI,IAAI,CAAC,IAAI,KAAK,gBAAgB,EAAE;AAChC,mBAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;;;SAG7C,MAAM;AACH,uBAAO,kBAAkB,CAAC,IAAI,CAAC,CAAC;aACnC;KACJ;;;;;;AAMD,WAAO;;AAEH,qBAAa,EAAE,qBAAS,IAAI,EAAE;AAC1B,gBAAI,MAAM,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC,GAAG,EAAE;gBACrC,WAAW;gBACX,SAAS,CAAC;;;;AAId,gBAAI,MAAM,CAAC,IAAI,KAAK,aAAa,IAAI,MAAM,CAAC,SAAS,KAAK,IAAI,EAAE;AAC5D,uBAAO;aACV;;AAED,iBAAK,WAAW,GAAG,EAAE,EAAE,IAAI,CAAC,IAAI,KAAK,aAAa,EAAE,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE;AACvE,oBAAI,CAAC,IAAI,CAAC,SAAS,EAAE;AACjB,2BAAO;iBACV;AACD,2BAAW,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AAClC,yBAAS,GAAG,IAAI,CAAC,SAAS,CAAC;aAC9B;;AAED,gBAAI,WAAW,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE;AAClC,6BAAa,CAAC,SAAS,CAAC,CAAC;aAC5B;SACJ;;KAEJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"no-else-return-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Display the context report if rule is violated\n     *\n     * @param {Node} node The 'else' node\n     * @returns {void}\n     */\n    function displayReport(node) {\n        context.report(node, \"Unexpected 'else' after 'return'.\");\n    }\n\n    /**\n     * Check to see if the node is a ReturnStatement\n     *\n     * @param {Node} node The node being evaluated\n     * @returns {boolean} True if node is a return\n     */\n    function checkForReturn(node) {\n        return node.type === \"ReturnStatement\";\n    }\n\n    /**\n     * Naive return checking, does not iterate through the whole\n     * BlockStatement because we make the assumption that the ReturnStatement\n     * will be the last node in the body of the BlockStatement.\n     *\n     * @param {Node} node The consequent/alternate node\n     * @returns {boolean} True if it has a return\n     */\n    function naiveHasReturn(node) {\n        if (node.type === \"BlockStatement\") {\n            var body = node.body,\n                lastChildNode = body[body.length - 1];\n\n            return lastChildNode && checkForReturn(lastChildNode);\n        }\n        return checkForReturn(node);\n    }\n\n    /**\n     * Check to see if the node is valid for evaluation,\n     * meaning it has an else and not an else-if\n     *\n     * @param {Node} node The node being evaluated\n     * @returns {boolean} True if the node is valid\n     */\n    function hasElse(node) {\n        return node.alternate && node.consequent && node.alternate.type !== \"IfStatement\";\n    }\n\n    /**\n     * If the consequent is an IfStatement, check to see if it has an else\n     * and both its consequent and alternate path return, meaning this is\n     * a nested case of rule violation.  If-Else not considered currently.\n     *\n     * @param {Node} node The consequent node\n     * @returns {boolean} True if this is a nested rule violation\n     */\n    function checkForIf(node) {\n        return node.type === \"IfStatement\" && hasElse(node) &&\n            naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n    }\n\n    /**\n     * Check the consequent/body node to make sure it is not\n     * a ReturnStatement or an IfStatement that returns on both\n     * code paths.\n     *\n     * @param {Node} node The consequent or body node\n     * @param {Node} alternate The alternate node\n     * @returns {boolean} `true` if it is a Return/If node that always returns.\n     */\n    function checkForReturnOrIf(node) {\n        return checkForReturn(node) || checkForIf(node);\n    }\n\n\n    /**\n     * Check whether a node returns in every codepath.\n     * @param {Node} node The node to be checked\n     * @returns {boolean} `true` if it returns on every codepath.\n     */\n    function alwaysReturns(node) {\n        // If we have a BlockStatement, check each consequent body node.\n        if (node.type === \"BlockStatement\") {\n            return node.body.some(checkForReturnOrIf);\n        // If not a block statement, make sure the consequent isn't a ReturnStatement\n        // or an IfStatement with returns on both paths\n        } else {\n            return checkForReturnOrIf(node);\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n\n        \"IfStatement\": function(node) {\n            var parent = context.getAncestors().pop(),\n                consequents,\n                alternate;\n\n            // Only \"top-level\" if statements are checked, meaning the first `if`\n            // in a `if-else-if-...` chain.\n            if (parent.type === \"IfStatement\" && parent.alternate === node) {\n                return;\n            }\n\n            for (consequents = []; node.type === \"IfStatement\"; node = node.alternate) {\n                if (!node.alternate) {\n                    return;\n                }\n                consequents.push(node.consequent);\n                alternate = node.alternate;\n            }\n\n            if (consequents.every(alwaysReturns)) {\n                displayReport(alternate);\n            }\n        }\n\n    };\n\n};\n\nmodule.exports.schema = [];\n"]}