{"version":3,"sources":["no-cond-assign.js"],"names":[],"mappings":"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","file":"no-cond-assign-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\"use strict\";\n\nvar NODE_DESCRIPTIONS = {\n    \"DoWhileStatement\": \"a 'do...while' statement\",\n    \"ForStatement\": \"a 'for' statement\",\n    \"IfStatement\": \"an 'if' statement\",\n    \"WhileStatement\": \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var prohibitAssign = (context.options[0] || \"except-parens\");\n\n    /**\n     * Check whether an AST node is the test expression for a conditional statement.\n     * @param {!Object} node The node to test.\n     * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n     */\n    function isConditionalTestExpression(node) {\n        return node.parent &&\n            node.parent.test &&\n            node === node.parent.test;\n    }\n\n    /**\n     * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n     * @param {!Object} node The node to use at the start of the search.\n     * @returns {?Object} The closest ancestor node that represents a conditional statement.\n     */\n    function findConditionalAncestor(node) {\n        var currentAncestor = node;\n\n        do {\n            if (isConditionalTestExpression(currentAncestor)) {\n                return currentAncestor.parent;\n            }\n        } while ((currentAncestor = currentAncestor.parent));\n\n        return null;\n    }\n\n    /**\n     * Check whether the code represented by an AST node is enclosed in parentheses.\n     * @param {!Object} node The node to test.\n     * @returns {boolean} `true` if the code is enclosed in parentheses; otherwise, `false`.\n     */\n    function isParenthesised(node) {\n        var previousToken = context.getTokenBefore(node),\n            nextToken = context.getTokenAfter(node);\n\n        return previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n            nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n    }\n\n    /**\n     * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n     * @param {!Object} node The node to test.\n     * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n     */\n    function isParenthesisedTwice(node) {\n        var previousToken = context.getTokenBefore(node, 1),\n            nextToken = context.getTokenAfter(node, 1);\n\n        return isParenthesised(node) &&\n            previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n            nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n    }\n\n    /**\n     * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n     * @param {!Object} node The node for the conditional statement.\n     * @returns {void}\n     */\n    function testForAssign(node) {\n        if (node.test &&\n            (node.test.type === \"AssignmentExpression\") &&\n            (node.type === \"ForStatement\" ?\n                !isParenthesised(node.test) :\n                !isParenthesisedTwice(node.test)\n            )\n        ) {\n            // must match JSHint's error message\n            context.report({\n                node: node,\n                loc: node.test.loc.start,\n                message: \"Expected a conditional expression and instead saw an assignment.\"\n            });\n        }\n    }\n\n    /**\n     * Check whether an assignment expression is descended from a conditional statement's test expression.\n     * @param {!Object} node The node for the assignment expression.\n     * @returns {void}\n     */\n    function testForConditionalAncestor(node) {\n        var ancestor = findConditionalAncestor(node);\n\n        if (ancestor) {\n            context.report(ancestor, \"Unexpected assignment within {{type}}.\", {\n                type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n            });\n        }\n    }\n\n    if (prohibitAssign === \"always\") {\n        return {\n            \"AssignmentExpression\": testForConditionalAncestor\n        };\n    }\n\n    return {\n        \"DoWhileStatement\": testForAssign,\n        \"ForStatement\": testForAssign,\n        \"IfStatement\": testForAssign,\n        \"WhileStatement\": testForAssign\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"except-parens\", \"always\"]\n    }\n];\n"]}