{"version":3,"sources":["no-sequences.js"],"names":[],"mappings":";;;;;AAKA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;;;;AAK/B,QAAI,aAAa,GAAG;AAChB,0BAAkB,EAAE,MAAM;AAC1B,qBAAa,EAAE,MAAM;AACrB,yBAAiB,EAAE,cAAc;AACjC,wBAAgB,EAAE,MAAM;AACxB,uBAAe,EAAE,QAAQ;;;;;;KAM5B,CAAC;;;;;;;;AAQF,aAAS,mBAAmB,CAAC,IAAI,EAAE;AAC/B,eAAO,IAAI,CAAC,MAAM,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAC7C,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;KACjE;;;;;;;AAOD,aAAS,eAAe,CAAC,IAAI,EAAE;AAC3B,YAAI,aAAa,GAAG,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC;YAC5C,SAAS,GAAG,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;;AAE5C,eAAO,aAAa,IAAI,SAAS,IAC7B,aAAa,CAAC,KAAK,KAAK,GAAG,IAAI,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IACtE,SAAS,CAAC,KAAK,KAAK,GAAG,IAAI,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACtE;;;;;;;AAOD,aAAS,oBAAoB,CAAC,IAAI,EAAE;AAChC,YAAI,aAAa,GAAG,OAAO,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC;YAC/C,SAAS,GAAG,OAAO,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;;AAE/C,eAAO,eAAe,CAAC,IAAI,CAAC,IAAI,aAAa,IAAI,SAAS,IACtD,aAAa,CAAC,KAAK,KAAK,GAAG,IAAI,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IACtE,SAAS,CAAC,KAAK,KAAK,GAAG,IAAI,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACtE;;AAED,WAAO;AACH,4BAAoB,EAAE,4BAAS,IAAI,EAAE;;AAEjC,gBAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,cAAc,KAC9B,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA,AAAC,EAAE;AAChE,uBAAO;aACV;;;AAGD,gBAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;AAC3B,oBAAI,oBAAoB,CAAC,IAAI,CAAC,EAAE;AAC5B,2BAAO;iBACV;aACJ,MAAM;AACH,oBAAI,eAAe,CAAC,IAAI,CAAC,EAAE;AACvB,2BAAO;iBACV;aACJ;;AAED,mBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,mCAAmC,CAAC,CAAC;SAC7D;KACJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC","file":"no-sequences-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag use of comma operator\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    /**\n     * Parts of the grammar that are required to have parens.\n     */\n    var parenthesized = {\n        \"DoWhileStatement\": \"test\",\n        \"IfStatement\": \"test\",\n        \"SwitchStatement\": \"discriminant\",\n        \"WhileStatement\": \"test\",\n        \"WithStatement\": \"object\"\n\n        // Omitting CallExpression - commas are parsed as argument separators\n        // Omitting NewExpression - commas are parsed as argument separators\n        // Omitting ForInStatement - parts aren't individually parenthesised\n        // Omitting ForStatement - parts aren't individually parenthesised\n    };\n\n    /**\n     * Determines whether a node is required by the grammar to be wrapped in\n     * parens, e.g. the test of an if statement.\n     * @param {ASTNode} node - The AST node\n     * @returns {boolean} True if parens around node belong to parent node.\n     */\n    function requiresExtraParens(node) {\n        return node.parent && parenthesized[node.parent.type] &&\n                node === node.parent[parenthesized[node.parent.type]];\n    }\n\n    /**\n     * Check if a node is wrapped in parens.\n     * @param {ASTNode} node - The AST node\n     * @returns {boolean} True if the node has a paren on each side.\n     */\n    function isParenthesised(node) {\n        var previousToken = context.getTokenBefore(node),\n            nextToken = context.getTokenAfter(node);\n\n        return previousToken && nextToken &&\n            previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n            nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n    }\n\n    /**\n     * Check if a node is wrapped in two levels of parens.\n     * @param {ASTNode} node - The AST node\n     * @returns {boolean} True if two parens surround the node on each side.\n     */\n    function isParenthesisedTwice(node) {\n        var previousToken = context.getTokenBefore(node, 1),\n            nextToken = context.getTokenAfter(node, 1);\n\n        return isParenthesised(node) && previousToken && nextToken &&\n            previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n            nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n    }\n\n    return {\n        \"SequenceExpression\": function(node) {\n            // Always allow sequences in for statement update\n            if (node.parent.type === \"ForStatement\" &&\n                    (node === node.parent.init || node === node.parent.update)) {\n                return;\n            }\n\n            // Wrapping a sequence in extra parens indicates intent\n            if (requiresExtraParens(node)) {\n                if (isParenthesisedTwice(node)) {\n                    return;\n                }\n            } else {\n                if (isParenthesised(node)) {\n                    return;\n                }\n            }\n\n            context.report(node, \"Unexpected use of comma operator.\");\n        }\n    };\n\n};\n\nmodule.exports.schema = [];\n"]}