{"version":3,"sources":["wrap-iife.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,SAAS,CAAC;;;;;;;;AAQ5C,aAAS,OAAO,CAAC,IAAI,EAAE;AACnB,YAAI,aAAa,GAAG,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC;YAC5C,SAAS,GAAG,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;AAC5C,eAAO,aAAa,IAAI,aAAa,CAAC,KAAK,KAAK,GAAG,IAC/C,SAAS,IAAI,SAAS,CAAC,KAAK,KAAK,GAAG,CAAC;KAC5C;;AAED,WAAO;;AAEH,wBAAgB,EAAE,wBAAS,IAAI,EAAE;AAC7B,gBAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,oBAAoB,EAAE;AAC3C,oBAAI,qBAAqB,GAAG,OAAO,CAAC,IAAI,CAAC;oBACrC,yBAAyB,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;;AAErD,oBAAI,CAAC,qBAAqB,IAAI,CAAC,yBAAyB,EAAE;AACtD,2BAAO,CAAC,MAAM,CAAC,IAAI,EAAE,uDAAuD,CAAC,CAAC;iBACjF,MAAM,IAAI,KAAK,KAAK,QAAQ,IAAI,CAAC,yBAAyB,EAAE;AACzD,2BAAO,CAAC,MAAM,CAAC,IAAI,EAAE,8CAA8C,CAAC,CAAC;iBACxE,MAAM,IAAI,KAAK,KAAK,SAAS,IAAI,CAAC,qBAAqB,EAAE;AACtD,2BAAO,CAAC,MAAM,CAAC,IAAI,EAAE,gEAAgE,CAAC,CAAC;iBAC1F;aACJ;SACJ;KACJ,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,CAAC,SAAS,EAAE,QAAQ,EAAE,KAAK,CAAC;CACvC,CACJ,CAAC","file":"wrap-iife-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n * @copyright 2013 Ilya Volodin. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var style = context.options[0] || \"outside\";\n\n    /**\n     * Check if the node is wrapped in ()\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if it is wrapped\n     * @private\n     */\n    function wrapped(node) {\n        var previousToken = context.getTokenBefore(node),\n            nextToken = context.getTokenAfter(node);\n        return previousToken && previousToken.value === \"(\" &&\n            nextToken && nextToken.value === \")\";\n    }\n\n    return {\n\n        \"CallExpression\": function(node) {\n            if (node.callee.type === \"FunctionExpression\") {\n                var callExpressionWrapped = wrapped(node),\n                    functionExpressionWrapped = wrapped(node.callee);\n\n                if (!callExpressionWrapped && !functionExpressionWrapped) {\n                    context.report(node, \"Wrap an immediate function invocation in parentheses.\");\n                } else if (style === \"inside\" && !functionExpressionWrapped) {\n                    context.report(node, \"Wrap only the function expression in parens.\");\n                } else if (style === \"outside\" && !callExpressionWrapped) {\n                    context.report(node, \"Move the invocation into the parens that contain the function.\");\n                }\n            }\n        }\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"outside\", \"inside\", \"any\"]\n    }\n];\n"]}