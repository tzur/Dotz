{"version":3,"sources":["handle-callback-err.js"],"names":[],"mappings":";;;;;;;AAOA,YAAY,CAAC;;;;;;AAMb,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,aAAa,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;;;;;;;AAOhD,aAAS,SAAS,CAAC,aAAa,EAAE;AAC9B,YAAI,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AACjC,eAAO,SAAS,KAAK,GAAG,CAAC;KAC5B;;;;;;;AAOD,aAAS,0BAA0B,CAAC,IAAI,EAAE;AACtC,YAAI,SAAS,CAAC,aAAa,CAAC,EAAE;AAC1B,gBAAI,MAAM,GAAG,IAAI,MAAM,CAAC,aAAa,CAAC,CAAC;AACvC,mBAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC5B;AACD,eAAO,IAAI,KAAK,aAAa,CAAC;KACjC;;;;;;;AAOD,aAAS,aAAa,CAAC,KAAK,EAAE;AAC1B,eAAO,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,UAAS,QAAQ,EAAE;AAC7C,mBAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,WAAW,CAAC;SACpE,CAAC,CAAC;KACN;;;;;;;AAOD,aAAS,aAAa,CAAC,IAAI,EAAE;AACzB,YAAI,KAAK,GAAG,OAAO,CAAC,QAAQ,EAAE;YAC1B,UAAU,GAAG,aAAa,CAAC,KAAK,CAAC;YACjC,cAAc,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;;AAEnC,YAAI,cAAc,IAAI,0BAA0B,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;AACnE,gBAAI,cAAc,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;AACxC,uBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,+BAA+B,CAAC,CAAC;aACzD;SACJ;KACJ;;AAED,WAAO;AACH,6BAAqB,EAAE,aAAa;AACpC,4BAAoB,EAAE,aAAa;AACnC,iCAAyB,EAAE,aAAa;KAC3C,CAAC;CAEL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,QAAQ;CACnB,CACJ,CAAC","file":"handle-callback-err-compiled.js","sourcesContent":["/**\n * @fileoverview Ensure handling of errors when we know they exist.\n * @author Jamund Ferguson\n * @copyright 2015 Mathias Schreck.\n * @copyright 2014 Jamund Ferguson. All rights reserved.\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var errorArgument = context.options[0] || \"err\";\n\n    /**\n     * Checks if the given argument should be interpreted as a regexp pattern.\n     * @param {string} stringToCheck The string which should be checked.\n     * @returns {boolean} Whether or not the string should be interpreted as a pattern.\n     */\n    function isPattern(stringToCheck) {\n        var firstChar = stringToCheck[0];\n        return firstChar === \"^\";\n    }\n\n    /**\n     * Checks if the given name matches the configured error argument.\n     * @param {string} name The name which should be compared.\n     * @returns {boolean} Whether or not the given name matches the configured error variable name.\n     */\n    function matchesConfiguredErrorName(name) {\n        if (isPattern(errorArgument)) {\n            var regexp = new RegExp(errorArgument);\n            return regexp.test(name);\n        }\n        return name === errorArgument;\n    }\n\n    /**\n     * Get the parameters of a given function scope.\n     * @param {object} scope The function scope.\n     * @returns {array} All parameters of the given scope.\n     */\n    function getParameters(scope) {\n        return scope.variables.filter(function(variable) {\n            return variable.defs[0] && variable.defs[0].type === \"Parameter\";\n        });\n    }\n\n    /**\n     * Check to see if we're handling the error object properly.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     */\n    function checkForError(node) {\n        var scope = context.getScope(),\n            parameters = getParameters(scope),\n            firstParameter = parameters[0];\n\n        if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {\n            if (firstParameter.references.length === 0) {\n                context.report(node, \"Expected error to be handled.\");\n            }\n        }\n    }\n\n    return {\n        \"FunctionDeclaration\": checkForError,\n        \"FunctionExpression\": checkForError,\n        \"ArrowFunctionExpression\": checkForError\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"string\"\n    }\n];\n"]}