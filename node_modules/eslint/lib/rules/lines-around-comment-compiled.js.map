{"version":3,"sources":["lines-around-comment.js"],"names":[],"mappings":";;;;;;;AAOA,YAAY,CAAC;;;;;;;AAOb,SAAS,gBAAgB,CAAC,KAAK,EAAE;AAC7B,QAAI,UAAU,GAAG,KAAK,CAAC,GAAG,CAAC,UAAS,IAAI,EAAE,CAAC,EAAE;AACzC,eAAO;AACH,gBAAI,EAAE,IAAI,CAAC,IAAI,EAAE;AACjB,eAAG,EAAE,CAAC,GAAG,CAAC;SACb,CAAC;KACL,CAAC,CAAC,MAAM,CAAC,UAAS,IAAI,EAAE;AACrB,eAAO,CAAC,IAAI,CAAC,IAAI,CAAC;KACrB,CAAC,CAAC,GAAG,CAAC,UAAS,IAAI,EAAE;AAClB,eAAO,IAAI,CAAC,GAAG,CAAC;KACnB,CAAC,CAAC;AACH,WAAO,UAAU,CAAC;CACrB;;;;;;;AAOD,SAAS,kBAAkB,CAAC,QAAQ,EAAE;AAClC,QAAI,KAAK,GAAG,EAAE,CAAC;AACf,YAAQ,CAAC,OAAO,CAAC,UAAS,KAAK,EAAE;AAC7B,YAAI,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC;AACjC,YAAI,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC;AAC7B,aAAK,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;KAC1B,CAAC,CAAC;AACH,WAAO,KAAK,CAAC;CAChB;;;;;;;;AAQD,SAAS,QAAQ,CAAC,GAAG,EAAE,KAAK,EAAE;AAC1B,WAAO,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;CAClC;;;;;;AAMD,MAAM,CAAC,OAAO,GAAG,UAAS,OAAO,EAAE;;AAE/B,QAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACvC,WAAO,CAAC,iBAAiB,GAAG,OAAO,CAAC,iBAAiB,IAAI,KAAK,CAAC;AAC/D,WAAO,CAAC,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,IAAI,KAAK,CAAC;AAC7D,WAAO,CAAC,kBAAkB,GAAG,OAAO,OAAO,CAAC,kBAAkB,KAAK,WAAW,GAAG,OAAO,CAAC,kBAAkB,GAAG,IAAI,CAAC;AACnH,WAAO,CAAC,iBAAiB,GAAG,OAAO,CAAC,iBAAiB,IAAI,KAAK,CAAC;AAC/D,WAAO,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,IAAI,KAAK,CAAC;AAC3D,WAAO,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,IAAI,KAAK,CAAC;;;;;;;AAOvD,aAAS,iBAAiB,CAAC,IAAI,EAAE;;AAE7B,YAAI,KAAK,GAAG,OAAO,CAAC,cAAc,EAAE,CAAC;;;AAGrC,YAAI,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;AAC/C,YAAI,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;;AAE3C,YAAI,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC;;;AAGhE,YAAI,SAAS,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC;;;AAG1D,eAAO,CAAC,EAAE,QAAQ,IAAI,SAAS,CAAA,AAAC,CAAC;KACpC;;;;;;;;;AASD,aAAS,uBAAuB,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE;AACrD,eAAO,MAAM,CAAC,IAAI,KAAK,QAAQ,IAAK,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,QAAQ,AAAC,CAAC;KACrF;;;;;;;;AAQD,aAAS,sBAAsB,CAAC,IAAI,EAAE,QAAQ,EAAE;AAC5C,YAAI,SAAS,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC;AACvC,YAAI,MAAM,CAAC;;AAEX,YAAI,SAAS,CAAC,MAAM,EAAE;AAClB,kBAAM,GAAG,SAAS,CAAC,GAAG,EAAE,CAAC;SAC5B;;AAED,eAAO,MAAM,IAAI,uBAAuB,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC,IACxD,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC;KAC7D;;;;;;;;AAQD,aAAS,oBAAoB,CAAC,IAAI,EAAE,QAAQ,EAAE;AAC1C,YAAI,SAAS,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC;AACvC,YAAI,MAAM,CAAC;;AAEX,YAAI,SAAS,CAAC,MAAM,EAAE;AAClB,kBAAM,GAAG,SAAS,CAAC,GAAG,EAAE,CAAC;SAC5B;;AAED,eAAO,MAAM,IAAI,uBAAuB,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC,IACxD,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,CAAC;KACzD;;;;;;;AAOD,aAAS,qBAAqB,CAAC,IAAI,EAAE;AACjC,eAAO,sBAAsB,CAAC,IAAI,EAAE,WAAW,CAAC,IAAI,sBAAsB,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;KACtG;;;;;;;AAOD,aAAS,mBAAmB,CAAC,IAAI,EAAE;AAC/B,eAAO,oBAAoB,CAAC,IAAI,EAAE,WAAW,CAAC,IAAI,oBAAoB,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;KAClG;;;;;;;AAOD,aAAS,sBAAsB,CAAC,IAAI,EAAE;AAClC,eAAO,sBAAsB,CAAC,IAAI,EAAE,kBAAkB,CAAC,IAAI,sBAAsB,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;KAC5G;;;;;;;AAOD,aAAS,oBAAoB,CAAC,IAAI,EAAE;AAChC,eAAO,oBAAoB,CAAC,IAAI,EAAE,kBAAkB,CAAC,IAAI,oBAAoB,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;KACxG;;;;;;;AAOD,aAAS,qBAAqB,CAAC,IAAI,EAAE;AACjC,eAAO,sBAAsB,CAAC,IAAI,EAAE,iBAAiB,CAAC,IAAI,sBAAsB,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;KAC1G;;;;;;;AAOD,aAAS,mBAAmB,CAAC,IAAI,EAAE;AAC/B,eAAO,oBAAoB,CAAC,IAAI,EAAE,iBAAiB,CAAC,IAAI,oBAAoB,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;KACtG;;;;;;;;;;AAUD,aAAS,iBAAiB,CAAC,IAAI,EAAE,IAAI,EAAE;;AAEnC,YAAI,KAAK,GAAG,OAAO,CAAC,cAAc,EAAE;YAChC,QAAQ,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC;YAC3B,QAAQ,GAAG,OAAO,CAAC,cAAc,EAAE;YACnC,YAAY,GAAG,kBAAkB,CAAC,QAAQ,CAAC;YAC3C,UAAU,GAAG,gBAAgB,CAAC,KAAK,CAAC;YACpC,oBAAoB,GAAG,YAAY,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;;AAE3D,YAAI,KAAK,GAAG,IAAI,CAAC,KAAK;YAClB,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;;AAEzB,YAAI,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC;YACrC,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC;YACnC,iBAAiB,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;;AAEhD,YAAI,iBAAiB,GAAG,OAAO,CAAC,eAAe,IAAI,qBAAqB,CAAC,IAAI,CAAC;YAC1E,eAAe,GAAG,OAAO,CAAC,aAAa,IAAI,mBAAmB,CAAC,IAAI,CAAC;YACpE,kBAAkB,GAAG,OAAO,CAAC,gBAAgB,IAAI,sBAAsB,CAAC,IAAI,CAAC;YAC7E,gBAAgB,GAAG,OAAO,CAAC,cAAc,IAAI,oBAAoB,CAAC,IAAI,CAAC;YACvE,iBAAiB,GAAG,OAAO,CAAC,eAAe,IAAI,qBAAqB,CAAC,IAAI,CAAC;YAC1E,eAAe,GAAG,OAAO,CAAC,aAAa,IAAI,mBAAmB,CAAC,IAAI,CAAC,CAAC;;AAEzE,YAAI,qBAAqB,GAAG,iBAAiB,IAAI,kBAAkB,IAAI,iBAAiB,CAAC;AACzF,YAAI,mBAAmB,GAAG,eAAe,IAAI,gBAAgB,IAAI,eAAe,CAAC;;;AAGjF,YAAI,WAAW,GAAG,CAAC,EAAE;AACjB,kBAAM,GAAG,KAAK,CAAC;SAClB;AACD,YAAI,WAAW,IAAI,QAAQ,EAAE;AACzB,iBAAK,GAAG,KAAK,CAAC;SACjB;;;AAGD,YAAI,iBAAiB,EAAE;AACnB,mBAAO;SACV;;;AAGD,YAAI,CAAC,qBAAqB,IAAI,MAAM,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,oBAAoB,CAAC,EAAE;AAClF,mBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,+BAA+B,CAAC,CAAC;SACzD;;;AAGD,YAAI,CAAC,mBAAmB,IAAI,KAAK,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,oBAAoB,CAAC,EAAE;AAC/E,mBAAO,CAAC,MAAM,CAAC,IAAI,EAAE,8BAA8B,CAAC,CAAC;SACxD;KAEJ;;;;;;AAMD,WAAO;;AAEH,qBAAa,EAAE,qBAAS,IAAI,EAAE;AAC1B,gBAAI,OAAO,CAAC,iBAAiB,IAAI,OAAO,CAAC,gBAAgB,EAAE;AACvD,iCAAiB,CAAC,IAAI,EAAE;AACpB,yBAAK,EAAE,OAAO,CAAC,gBAAgB;AAC/B,0BAAM,EAAE,OAAO,CAAC,iBAAiB;iBACpC,CAAC,CAAC;aACN;SACJ;;AAED,sBAAc,EAAE,sBAAS,IAAI,EAAE;AAC3B,gBAAI,OAAO,CAAC,kBAAkB,IAAI,OAAO,CAAC,iBAAiB,EAAE;AACzD,iCAAiB,CAAC,IAAI,EAAE;AACpB,yBAAK,EAAE,OAAO,CAAC,iBAAiB;AAChC,0BAAM,EAAE,OAAO,CAAC,kBAAkB;iBACrC,CAAC,CAAC;aACN;SACJ;;KAEJ,CAAC;CACL,CAAC;;AAEF,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CACpB;AACI,UAAM,EAAE,QAAQ;AAChB,gBAAY,EAAE;AACV,4BAAoB,EAAE;AAClB,kBAAM,EAAE,SAAS;SACpB;AACD,2BAAmB,EAAE;AACjB,kBAAM,EAAE,SAAS;SACpB;AACD,2BAAmB,EAAE;AACjB,kBAAM,EAAE,SAAS;SACpB;AACD,0BAAkB,EAAE;AAChB,kBAAM,EAAE,SAAS;SACpB;AACD,yBAAiB,EAAE;AACf,kBAAM,EAAE,SAAS;SACpB;AACD,uBAAe,EAAE;AACb,kBAAM,EAAE,SAAS;SACpB;AACD,0BAAkB,EAAE;AAChB,kBAAM,EAAE,SAAS;SACpB;AACD,wBAAgB,EAAE;AACd,kBAAM,EAAE,SAAS;SACpB;AACD,yBAAiB,EAAE;AACf,kBAAM,EAAE,SAAS;SACpB;AACD,uBAAe,EAAE;AACb,kBAAM,EAAE,SAAS;SACpB;KACJ;AACD,0BAAsB,EAAE,KAAK;CAChC,CACJ,CAAC","file":"lines-around-comment-compiled.js","sourcesContent":["/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n * @copyright 2015 Mathieu M-Gosselin. All rights reserved.\n * @copyright 2015 Jamund Ferguson. All rights reserved.\n * @copyright 2015 Gyandeep Singh. All rights reserved.\n */\n\"use strict\";\n\n/**\n * Return an array with with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n    var emptyLines = lines.map(function(line, i) {\n        return {\n            code: line.trim(),\n            num: i + 1\n        };\n    }).filter(function(line) {\n        return !line.code;\n    }).map(function(line) {\n        return line.num;\n    });\n    return emptyLines;\n}\n\n/**\n * Return an array with with any line numbers that contain comments.\n * @param {Array} comments An array of comment nodes.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n    var lines = [];\n    comments.forEach(function(token) {\n        var start = token.loc.start.line;\n        var end = token.loc.end.line;\n        lines.push(start, end);\n    });\n    return lines;\n}\n\n/**\n * Determines if a value is an array.\n * @param {number} val The value we wish to check for in the array..\n * @param {Array} array An array.\n * @returns {boolean} True if the value is in the array..\n */\nfunction contains(val, array) {\n    return array.indexOf(val) > -1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var options = context.options[0] || {};\n    options.beforeLineComment = options.beforeLineComment || false;\n    options.afterLineComment = options.afterLineComment || false;\n    options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n    options.afterBlockComment = options.afterBlockComment || false;\n    options.allowBlockStart = options.allowBlockStart || false;\n    options.allowBlockEnd = options.allowBlockEnd || false;\n\n    /**\n     * Returns whether or not comments are not on lines starting with or ending with code\n     * @param {ASTNode} node The comment node to check.\n     * @returns {boolean} True if the comment is not alone.\n     */\n    function codeAroundComment(node) {\n\n        var lines = context.getSourceLines();\n\n        // Get the whole line and cut it off at the start of the comment\n        var startLine = lines[node.loc.start.line - 1];\n        var endLine = lines[node.loc.end.line - 1];\n\n        var preamble = startLine.slice(0, node.loc.start.column).trim();\n\n        // Also check after the comment\n        var postamble = endLine.slice(node.loc.end.column).trim();\n\n        // Should be false if there was only whitespace around the comment\n        return !!(preamble || postamble);\n    }\n\n    /**\n     * Returns whether or not comments are inside a node type or not.\n     * @param {ASTNode} node The Comment node.\n     * @param {ASTNode} parent The Comment parent node.\n     * @param {string} nodeType The parent type to check against.\n     * @returns {boolean} True if the comment is inside nodeType.\n     */\n    function isCommentInsideNodeType(node, parent, nodeType) {\n        return parent.type === nodeType || (parent.body && parent.body.type === nodeType);\n    }\n\n    /**\n     * Returns whether or not comments are at the parent start or not.\n     * @param {ASTNode} node The Comment node.\n     * @param {string} nodeType The parent type to check against.\n     * @returns {boolean} True if the comment is at parent start.\n     */\n    function isCommentAtParentStart(node, nodeType) {\n        var ancestors = context.getAncestors();\n        var parent;\n\n        if (ancestors.length) {\n            parent = ancestors.pop();\n        }\n\n        return parent && isCommentInsideNodeType(node, parent, nodeType) &&\n                node.loc.start.line - parent.loc.start.line === 1;\n    }\n\n    /**\n     * Returns whether or not comments are at the parent end or not.\n     * @param {ASTNode} node The Comment node.\n     * @param {string} nodeType The parent type to check against.\n     * @returns {boolean} True if the comment is at parent end.\n     */\n    function isCommentAtParentEnd(node, nodeType) {\n        var ancestors = context.getAncestors();\n        var parent;\n\n        if (ancestors.length) {\n            parent = ancestors.pop();\n        }\n\n        return parent && isCommentInsideNodeType(node, parent, nodeType) &&\n                parent.loc.end.line - node.loc.end.line === 1;\n    }\n\n    /**\n     * Returns whether or not comments are at the block start or not.\n     * @param {ASTNode} node The Comment node.\n     * @returns {boolean} True if the comment is at block start.\n     */\n    function isCommentAtBlockStart(node) {\n        return isCommentAtParentStart(node, \"ClassBody\") || isCommentAtParentStart(node, \"BlockStatement\");\n    }\n\n    /**\n     * Returns whether or not comments are at the block end or not.\n     * @param {ASTNode} node The Comment node.\n     * @returns {boolean} True if the comment is at block end.\n     */\n    function isCommentAtBlockEnd(node) {\n        return isCommentAtParentEnd(node, \"ClassBody\") || isCommentAtParentEnd(node, \"BlockStatement\");\n    }\n\n    /**\n     * Returns whether or not comments are at the object start or not.\n     * @param {ASTNode} node The Comment node.\n     * @returns {boolean} True if the comment is at object start.\n     */\n    function isCommentAtObjectStart(node) {\n        return isCommentAtParentStart(node, \"ObjectExpression\") || isCommentAtParentStart(node, \"ObjectPattern\");\n    }\n\n    /**\n     * Returns whether or not comments are at the object end or not.\n     * @param {ASTNode} node The Comment node.\n     * @returns {boolean} True if the comment is at object end.\n     */\n    function isCommentAtObjectEnd(node) {\n        return isCommentAtParentEnd(node, \"ObjectExpression\") || isCommentAtParentEnd(node, \"ObjectPattern\");\n    }\n\n    /**\n     * Returns whether or not comments are at the array start or not.\n     * @param {ASTNode} node The Comment node.\n     * @returns {boolean} True if the comment is at array start.\n     */\n    function isCommentAtArrayStart(node) {\n        return isCommentAtParentStart(node, \"ArrayExpression\") || isCommentAtParentStart(node, \"ArrayPattern\");\n    }\n\n    /**\n     * Returns whether or not comments are at the array end or not.\n     * @param {ASTNode} node The Comment node.\n     * @returns {boolean} True if the comment is at array end.\n     */\n    function isCommentAtArrayEnd(node) {\n        return isCommentAtParentEnd(node, \"ArrayExpression\") || isCommentAtParentEnd(node, \"ArrayPattern\");\n    }\n\n    /**\n     * Checks if a comment node has lines around it (ignores inline comments)\n     * @param {ASTNode} node The Comment node.\n     * @param {Object} opts Options to determine the newline.\n     * @param {Boolean} opts.after Should have a newline after this line.\n     * @param {Boolean} opts.before Should have a newline before this line.\n     * @returns {void}\n     */\n    function checkForEmptyLine(node, opts) {\n\n        var lines = context.getSourceLines(),\n            numLines = lines.length + 1,\n            comments = context.getAllComments(),\n            commentLines = getCommentLineNums(comments),\n            emptyLines = getEmptyLineNums(lines),\n            commentAndEmptyLines = commentLines.concat(emptyLines);\n\n        var after = opts.after,\n            before = opts.before;\n\n        var prevLineNum = node.loc.start.line - 1,\n            nextLineNum = node.loc.end.line + 1,\n            commentIsNotAlone = codeAroundComment(node);\n\n        var blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(node),\n            blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(node),\n            objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(node),\n            objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(node),\n            arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(node),\n            arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(node);\n\n        var exceptionStartAllowed = blockStartAllowed || objectStartAllowed || arrayStartAllowed;\n        var exceptionEndAllowed = blockEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n        // ignore top of the file and bottom of the file\n        if (prevLineNum < 1) {\n            before = false;\n        }\n        if (nextLineNum >= numLines) {\n            after = false;\n        }\n\n        // we ignore all inline comments\n        if (commentIsNotAlone) {\n            return;\n        }\n\n        // check for newline before\n        if (!exceptionStartAllowed && before && !contains(prevLineNum, commentAndEmptyLines)) {\n            context.report(node, \"Expected line before comment.\");\n        }\n\n        // check for newline after\n        if (!exceptionEndAllowed && after && !contains(nextLineNum, commentAndEmptyLines)) {\n            context.report(node, \"Expected line after comment.\");\n        }\n\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n\n        \"LineComment\": function(node) {\n            if (options.beforeLineComment || options.afterLineComment) {\n                checkForEmptyLine(node, {\n                    after: options.afterLineComment,\n                    before: options.beforeLineComment\n                });\n            }\n        },\n\n        \"BlockComment\": function(node) {\n            if (options.beforeBlockComment || options.afterBlockComment) {\n                checkForEmptyLine(node, {\n                    after: options.afterBlockComment,\n                    before: options.beforeBlockComment\n                });\n            }\n        }\n\n    };\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"beforeBlockComment\": {\n                \"type\": \"boolean\"\n            },\n            \"afterBlockComment\": {\n                \"type\": \"boolean\"\n            },\n            \"beforeLineComment\": {\n                \"type\": \"boolean\"\n            },\n            \"afterLineComment\": {\n                \"type\": \"boolean\"\n            },\n            \"allowBlockStart\": {\n                \"type\": \"boolean\"\n            },\n            \"allowBlockEnd\": {\n                \"type\": \"boolean\"\n            },\n            \"allowObjectStart\": {\n                \"type\": \"boolean\"\n            },\n            \"allowObjectEnd\": {\n                \"type\": \"boolean\"\n            },\n            \"allowArrayStart\": {\n                \"type\": \"boolean\"\n            },\n            \"allowArrayEnd\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n"]}