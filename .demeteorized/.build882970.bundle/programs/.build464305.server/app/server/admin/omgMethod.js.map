{"version":3,"sources":["meteor://ðŸ’»app/server/admin/omgMethod.js"],"names":[],"mappings":"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","file":"/server/admin/omgMethod.js","sourcesContent":["\nMeteor.methods({\n\n  omgCall(smartRef){\n\n    check(smartRef, Schema.dotSmartRef);\n    check(userId, Meteor.userId());\n    if (userId === undefined || userId === null){\n      return false;\n    }\n\n\n    //  security check:\n\n    if ( Meteor.user().username != ( \"Dotz\" || \"Otni\" || \"Aviv Hatzir\" || \"Yoav Sibony\" || \"Zur Tene\") ) {\n      return false\n    }\n\n\n    let theFakeLake = [\n      \"Otni\",\n      \"Dotz\"\n      //\"Ben Lo\",\n      //\"Andi Dagan\",\n      //\"Laura Melrose\",\n      //\"Michal Rinat\",\n      //\"Tori Null\",\n      //\"Will Anderson\",\n      //\"Laura Kirsh\",\n      //\"Paloma Hernandez\",\n      //\"Jackie Melrose\",\n      //\"Luis van Beuren\",\n      //\"Leo Kalderon\",\n      //\"Rose Shine\",\n      //\"Tom James\",\n      //\"Bob Geller\",\n      //\"Nill Watson\"\n    ];\n\n    let i = Math.floor((Math.random() * theFakeLake.length) + 1);\n    //\n\n\n\n\n    Meteor.call('likeDot', smartRef.connection.toParentDotId, smartRef.dot._id, userId, function(error, result){\n      if (error){\n        console.log(\"Error \"+ error);\n      }\n      else{\n        Meteor.call('updateTotalUpvotes', smartRef.dot._id, smartRef.connection.toParentDotId, function(error, result){\n          if(error){\n            console.log(\"Error in 'updateTotalUpvotes': \" + error)\n          }\n        });\n        let parentDot = Dotz.findOne(smartRef.connection.toParentDotId);\n        if(parentDot.isOpen){\n          //If we have more than one variable at the array\n          if (parentDot.connectedDotzArray.length > 1){\n            let currentIndex =0;\n            //Find the current smartRef index.\n            while (parentDot.connectedDotzArray[currentIndex].dot._id != smartRef.dot._id){\n              currentIndex++;\n            }\n            //if he is not at the top..(we are at like action so we have nothing to do...)\n            if (currentIndex != 0) {\n              let tempIndex = currentIndex; // temporary index just for the current iteration\n              let newIndex = currentIndex; //will save our new index\n              while (tempIndex != 0) {\n                tempIndex -= 1;\n                //check if the dot that is located from left of me have less likes than me.\n                if (parentDot.connectedDotzArray[tempIndex].connection.likes.length <\n                  parentDot.connectedDotzArray[currentIndex].connection.likes.length) {\n                  newIndex = tempIndex; // i need to replace her, so save her index\n                }\n                else{\n                  break; // if one is bigger than me than sure all of the rest are, no need to keep iterating.\n                }\n              }\n              // if the newIndex was changed, lets update the array with it's new order.\n              if (newIndex != currentIndex){\n                Meteor.call('sortByLikes',parentDot.connectedDotzArray[currentIndex],\n                  smartRef.connection.toParentDotId ,newIndex, function(error,result){\n                    if (error){\n                      console.log(\"ERROR \" + error);\n                    }\n                  })\n              }\n            }\n          }\n        }\n      }\n    });\n\n\n\n  }\n\n});\n\n\n\n\n\n\nlet _likeDot = function(smartRef, userId){\n  check(smartRef, Schema.dotSmartRef);\n  check(userId, Meteor.userId());\n  if (userId === undefined || userId === null){\n    return false;\n  }\n  Meteor.call('likeDot', smartRef.connection.toParentDotId, smartRef.dot._id, userId, function(error, result){\n    if (error){\n      console.log(\"Error \"+ error);\n    }\n    else{\n      Meteor.call('updateTotalUpvotes', smartRef.dot._id, smartRef.connection.toParentDotId, function(error, result){\n        if(error){\n          console.log(\"Error in 'updateTotalUpvotes': \" + error)\n        }\n      });\n      let parentDot = Dotz.findOne(smartRef.connection.toParentDotId);\n      if(parentDot.isOpen){\n        //If we have more than one variable at the array\n        if (parentDot.connectedDotzArray.length > 1){\n          let currentIndex =0;\n          //Find the current smartRef index.\n          while (parentDot.connectedDotzArray[currentIndex].dot._id != smartRef.dot._id){\n            currentIndex++;\n          }\n          //if he is not at the top..(we are at like action so we have nothing to do...)\n          if (currentIndex != 0) {\n            let tempIndex = currentIndex; // temporary index just for the current iteration\n            let newIndex = currentIndex; //will save our new index\n            while (tempIndex != 0) {\n              tempIndex -= 1;\n              //check if the dot that is located from left of me have less likes than me.\n              if (parentDot.connectedDotzArray[tempIndex].connection.likes.length <\n                parentDot.connectedDotzArray[currentIndex].connection.likes.length) {\n                newIndex = tempIndex; // i need to replace her, so save her index\n              }\n              else{\n                break; // if one is bigger than me than sure all of the rest are, no need to keep iterating.\n              }\n            }\n            // if the newIndex was changed, lets update the array with it's new order.\n            if (newIndex != currentIndex){\n              Meteor.call('sortByLikes',parentDot.connectedDotzArray[currentIndex],\n                smartRef.connection.toParentDotId ,newIndex, function(error,result){\n                  if (error){\n                    console.log(\"ERROR \" + error);\n                  }\n                })\n            }\n          }\n        }\n      }\n    }\n  });\n};\n"]}